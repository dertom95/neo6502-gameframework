ca65 V2.18 - Ubuntu 2.19-1
Main file   : 6502_func_call_api.s
Current file: 6502_func_call_api.s

000000r 1               ;
000000r 1               ; File generated by cc65 v 2.18 - Ubuntu 2.19-1
000000r 1               ;
000000r 1               	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.19-1"
000000r 1               	.setcpu		"6502"
000000r 1               	.smart		on
000000r 1               	.autoimport	on
000000r 1               	.case		on
000000r 1               	.debuginfo	off
000000r 1               	.importzp	sp, sreg, regsave, regbank
000000r 1               	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
000000r 1               	.macpack	longbranch
000000r 2               .macro  jeq     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                       bne     *+5
000000r 2                       jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               beq     Target
000000r 2                       .else
000000r 2                               bne     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jne     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bne     Target
000000r 2                       .else
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jmi     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bmi     Target
000000r 2                       .else
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jpl     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bpl     Target
000000r 2                       .else
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcs     Target
000000r 2                       .else
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcc     Target
000000r 2                       .else
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvs     Target
000000r 2                       .else
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvc     Target
000000r 2                       .else
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 1               	.forceimport	__STARTUP__
000000r 1               	.export		_gfx_renderqueue_apply
000000r 1               	.export		_gfx_set_palettecolor
000000r 1               	.export		_gfx_get_palettecolor
000000r 1               	.export		_gfx_set_palette_from_assset
000000r 1               	.export		_gfx_set_font_from_asset
000000r 1               	.export		_gfx_get_pixel
000000r 1               	.export		_gfx_draw_pixel
000000r 1               	.export		_gfx_draw_char
000000r 1               	.export		_io_keyboard_is_pressed
000000r 1               	.export		_io_keyboard_is_down
000000r 1               	.export		_io_keyboard_is_released
000000r 1               	.export		_mem_call_function
000000r 1               	.export		_mem_call_result
000000r 1               	.export		_main
000000r 1               
000000r 1               .segment	"DATA"
000000r 1               
000000r 1               _mem_call_function:
000000r 1  08 F0        	.word	$F008
000002r 1               _mem_call_result:
000002r 1  0B F1        	.word	$F10B
000004r 1               
000004r 1               ; ---------------------------------------------------------------
000004r 1               ; void __near__ gfx_renderqueue_apply (void)
000004r 1               ; ---------------------------------------------------------------
000004r 1               
000004r 1               .segment	"CODE"
000000r 1               
000000r 1               .proc	_gfx_renderqueue_apply: near
000000r 1               
000000r 1               .segment	"CODE"
000000r 1               
000000r 1               ;
000000r 1               ; func_data = (call_gfx_renderqueue_apply_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000000r 1               ;
000000r 1  20 rr rr     	jsr     decsp3
000003r 1  A2 F1        	ldx     #$F1
000005r 1  A9 00        	lda     #$00
000007r 1  20 rr rr     	jsr     stax0sp
00000Ar 1               ;
00000Ar 1               ; func_data->hdr.func_type = 1;
00000Ar 1               ;
00000Ar 1  85 rr        	sta     ptr1
00000Cr 1  86 rr        	stx     ptr1+1
00000Er 1  A9 01        	lda     #$01
000010r 1  A0 00        	ldy     #$00
000012r 1  91 rr        	sta     (ptr1),y
000014r 1               ;
000014r 1               ; func_data->hdr.func_id = 1;
000014r 1               ;
000014r 1  C8           	iny
000015r 1  B1 rr        	lda     (sp),y
000017r 1  85 rr        	sta     ptr1+1
000019r 1  88           	dey
00001Ar 1  B1 rr        	lda     (sp),y
00001Cr 1  85 rr        	sta     ptr1
00001Er 1  A9 01        	lda     #$01
000020r 1  C8           	iny
000021r 1  91 rr        	sta     (ptr1),y
000023r 1               ;
000023r 1               ; result_code = *mem_call_function;
000023r 1               ;
000023r 1  AD rr rr     	lda     _mem_call_function+1
000026r 1  85 rr        	sta     ptr1+1
000028r 1  AD rr rr     	lda     _mem_call_function
00002Br 1  85 rr        	sta     ptr1
00002Dr 1  88           	dey
00002Er 1  B1 rr        	lda     (ptr1),y
000030r 1  A0 02        	ldy     #$02
000032r 1  91 rr        	sta     (sp),y
000034r 1               ;
000034r 1               ; }
000034r 1               ;
000034r 1  4C rr rr     	jmp     incsp3
000037r 1               
000037r 1               .endproc
000037r 1               
000037r 1               ; ---------------------------------------------------------------
000037r 1               ; void __near__ gfx_set_palettecolor (unsigned char, unsigned int)
000037r 1               ; ---------------------------------------------------------------
000037r 1               
000037r 1               .segment	"CODE"
000037r 1               
000037r 1               .proc	_gfx_set_palettecolor: near
000037r 1               
000037r 1               .segment	"CODE"
000037r 1               
000037r 1               ;
000037r 1               ; void     gfx_set_palettecolor(uint8_t color_idx, uint16_t color565){
000037r 1               ;
000037r 1  20 rr rr     	jsr     pushax
00003Ar 1               ;
00003Ar 1               ; func_data = (call_gfx_set_palettecolor_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00003Ar 1               ;
00003Ar 1  20 rr rr     	jsr     decsp3
00003Dr 1  A2 F1        	ldx     #$F1
00003Fr 1  A9 00        	lda     #$00
000041r 1  20 rr rr     	jsr     stax0sp
000044r 1               ;
000044r 1               ; func_data->hdr.func_type = 1;
000044r 1               ;
000044r 1  85 rr        	sta     ptr1
000046r 1  86 rr        	stx     ptr1+1
000048r 1  A9 01        	lda     #$01
00004Ar 1  A0 00        	ldy     #$00
00004Cr 1  91 rr        	sta     (ptr1),y
00004Er 1               ;
00004Er 1               ; func_data->hdr.func_id = 2;
00004Er 1               ;
00004Er 1  C8           	iny
00004Fr 1  B1 rr        	lda     (sp),y
000051r 1  85 rr        	sta     ptr1+1
000053r 1  88           	dey
000054r 1  B1 rr        	lda     (sp),y
000056r 1  85 rr        	sta     ptr1
000058r 1  A9 02        	lda     #$02
00005Ar 1  C8           	iny
00005Br 1  91 rr        	sta     (ptr1),y
00005Dr 1               ;
00005Dr 1               ; func_data->color_idx=color_idx;
00005Dr 1               ;
00005Dr 1  B1 rr        	lda     (sp),y
00005Fr 1  85 rr        	sta     ptr1+1
000061r 1  88           	dey
000062r 1  B1 rr        	lda     (sp),y
000064r 1  85 rr        	sta     ptr1
000066r 1  A0 05        	ldy     #$05
000068r 1  B1 rr        	lda     (sp),y
00006Ar 1  A0 02        	ldy     #$02
00006Cr 1  91 rr        	sta     (ptr1),y
00006Er 1               ;
00006Er 1               ; func_data->color565=color565;
00006Er 1               ;
00006Er 1  88           	dey
00006Fr 1  B1 rr        	lda     (sp),y
000071r 1  85 rr        	sta     ptr1+1
000073r 1  88           	dey
000074r 1  B1 rr        	lda     (sp),y
000076r 1  85 rr        	sta     ptr1
000078r 1  A0 04        	ldy     #$04
00007Ar 1  B1 rr        	lda     (sp),y
00007Cr 1  AA           	tax
00007Dr 1  88           	dey
00007Er 1  B1 rr        	lda     (sp),y
000080r 1  91 rr        	sta     (ptr1),y
000082r 1  C8           	iny
000083r 1  8A           	txa
000084r 1  91 rr        	sta     (ptr1),y
000086r 1               ;
000086r 1               ; result_code = *mem_call_function;
000086r 1               ;
000086r 1  AD rr rr     	lda     _mem_call_function+1
000089r 1  85 rr        	sta     ptr1+1
00008Br 1  AD rr rr     	lda     _mem_call_function
00008Er 1  85 rr        	sta     ptr1
000090r 1  A0 00        	ldy     #$00
000092r 1  B1 rr        	lda     (ptr1),y
000094r 1  A0 02        	ldy     #$02
000096r 1  91 rr        	sta     (sp),y
000098r 1               ;
000098r 1               ; }
000098r 1               ;
000098r 1  4C rr rr     	jmp     incsp6
00009Br 1               
00009Br 1               .endproc
00009Br 1               
00009Br 1               ; ---------------------------------------------------------------
00009Br 1               ; unsigned int __near__ gfx_get_palettecolor (unsigned char)
00009Br 1               ; ---------------------------------------------------------------
00009Br 1               
00009Br 1               .segment	"CODE"
00009Br 1               
00009Br 1               .proc	_gfx_get_palettecolor: near
00009Br 1               
00009Br 1               .segment	"CODE"
00009Br 1               
00009Br 1               ;
00009Br 1               ; uint16_t gfx_get_palettecolor(uint8_t color_idx){
00009Br 1               ;
00009Br 1  20 rr rr     	jsr     pusha
00009Er 1               ;
00009Er 1               ; func_data = (call_gfx_get_palettecolor_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00009Er 1               ;
00009Er 1  20 rr rr     	jsr     decsp3
0000A1r 1  A2 F1        	ldx     #$F1
0000A3r 1  A9 00        	lda     #$00
0000A5r 1  20 rr rr     	jsr     stax0sp
0000A8r 1               ;
0000A8r 1               ; func_data->hdr.func_type = 1;
0000A8r 1               ;
0000A8r 1  85 rr        	sta     ptr1
0000AAr 1  86 rr        	stx     ptr1+1
0000ACr 1  A9 01        	lda     #$01
0000AEr 1  A0 00        	ldy     #$00
0000B0r 1  91 rr        	sta     (ptr1),y
0000B2r 1               ;
0000B2r 1               ; func_data->hdr.func_id = 3;
0000B2r 1               ;
0000B2r 1  C8           	iny
0000B3r 1  B1 rr        	lda     (sp),y
0000B5r 1  85 rr        	sta     ptr1+1
0000B7r 1  88           	dey
0000B8r 1  B1 rr        	lda     (sp),y
0000BAr 1  85 rr        	sta     ptr1
0000BCr 1  A9 03        	lda     #$03
0000BEr 1  C8           	iny
0000BFr 1  91 rr        	sta     (ptr1),y
0000C1r 1               ;
0000C1r 1               ; func_data->color_idx=color_idx;
0000C1r 1               ;
0000C1r 1  B1 rr        	lda     (sp),y
0000C3r 1  85 rr        	sta     ptr1+1
0000C5r 1  88           	dey
0000C6r 1  B1 rr        	lda     (sp),y
0000C8r 1  85 rr        	sta     ptr1
0000CAr 1  A0 03        	ldy     #$03
0000CCr 1  B1 rr        	lda     (sp),y
0000CEr 1  88           	dey
0000CFr 1  91 rr        	sta     (ptr1),y
0000D1r 1               ;
0000D1r 1               ; result_code = *mem_call_function;
0000D1r 1               ;
0000D1r 1  AD rr rr     	lda     _mem_call_function+1
0000D4r 1  85 rr        	sta     ptr1+1
0000D6r 1  AD rr rr     	lda     _mem_call_function
0000D9r 1  85 rr        	sta     ptr1
0000DBr 1  A0 00        	ldy     #$00
0000DDr 1  B1 rr        	lda     (ptr1),y
0000DFr 1  A0 02        	ldy     #$02
0000E1r 1  91 rr        	sta     (sp),y
0000E3r 1               ;
0000E3r 1               ; uint16_t call_result = (uint16_t)*mem_call_result;
0000E3r 1               ;
0000E3r 1  AD rr rr     	lda     _mem_call_result+1
0000E6r 1  85 rr        	sta     ptr1+1
0000E8r 1  AD rr rr     	lda     _mem_call_result
0000EBr 1  85 rr        	sta     ptr1
0000EDr 1  A0 00        	ldy     #$00
0000EFr 1  B1 rr        	lda     (ptr1),y
0000F1r 1  20 rr rr     	jsr     pusha0
0000F4r 1               ;
0000F4r 1               ; return call_result;
0000F4r 1               ;
0000F4r 1  A0 01        	ldy     #$01
0000F6r 1  B1 rr        	lda     (sp),y
0000F8r 1  AA           	tax
0000F9r 1  88           	dey
0000FAr 1  B1 rr        	lda     (sp),y
0000FCr 1  20 rr rr     	jsr     incsp2
0000FFr 1               ;
0000FFr 1               ; }
0000FFr 1               ;
0000FFr 1  4C rr rr     	jmp     incsp4
000102r 1               
000102r 1               .endproc
000102r 1               
000102r 1               ; ---------------------------------------------------------------
000102r 1               ; void __near__ gfx_set_palette_from_assset (unsigned char, unsigned char)
000102r 1               ; ---------------------------------------------------------------
000102r 1               
000102r 1               .segment	"CODE"
000102r 1               
000102r 1               .proc	_gfx_set_palette_from_assset: near
000102r 1               
000102r 1               .segment	"CODE"
000102r 1               
000102r 1               ;
000102r 1               ; void     gfx_set_palette_from_assset(uint8_t asset_id, uint8_t fill_unused_with_idx){
000102r 1               ;
000102r 1  20 rr rr     	jsr     pusha
000105r 1               ;
000105r 1               ; func_data = (call_gfx_set_palette_from_assset_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000105r 1               ;
000105r 1  20 rr rr     	jsr     decsp3
000108r 1  A2 F1        	ldx     #$F1
00010Ar 1  A9 00        	lda     #$00
00010Cr 1  20 rr rr     	jsr     stax0sp
00010Fr 1               ;
00010Fr 1               ; func_data->hdr.func_type = 1;
00010Fr 1               ;
00010Fr 1  85 rr        	sta     ptr1
000111r 1  86 rr        	stx     ptr1+1
000113r 1  A9 01        	lda     #$01
000115r 1  A0 00        	ldy     #$00
000117r 1  91 rr        	sta     (ptr1),y
000119r 1               ;
000119r 1               ; func_data->hdr.func_id = 4;
000119r 1               ;
000119r 1  C8           	iny
00011Ar 1  B1 rr        	lda     (sp),y
00011Cr 1  85 rr        	sta     ptr1+1
00011Er 1  88           	dey
00011Fr 1  B1 rr        	lda     (sp),y
000121r 1  85 rr        	sta     ptr1
000123r 1  A9 04        	lda     #$04
000125r 1  C8           	iny
000126r 1  91 rr        	sta     (ptr1),y
000128r 1               ;
000128r 1               ; func_data->asset_id=asset_id;
000128r 1               ;
000128r 1  B1 rr        	lda     (sp),y
00012Ar 1  85 rr        	sta     ptr1+1
00012Cr 1  88           	dey
00012Dr 1  B1 rr        	lda     (sp),y
00012Fr 1  85 rr        	sta     ptr1
000131r 1  A0 04        	ldy     #$04
000133r 1  B1 rr        	lda     (sp),y
000135r 1  A0 02        	ldy     #$02
000137r 1  91 rr        	sta     (ptr1),y
000139r 1               ;
000139r 1               ; func_data->fill_unused_with_idx=fill_unused_with_idx;
000139r 1               ;
000139r 1  88           	dey
00013Ar 1  B1 rr        	lda     (sp),y
00013Cr 1  85 rr        	sta     ptr1+1
00013Er 1  88           	dey
00013Fr 1  B1 rr        	lda     (sp),y
000141r 1  85 rr        	sta     ptr1
000143r 1  A0 03        	ldy     #$03
000145r 1  B1 rr        	lda     (sp),y
000147r 1  91 rr        	sta     (ptr1),y
000149r 1               ;
000149r 1               ; result_code = *mem_call_function;
000149r 1               ;
000149r 1  AD rr rr     	lda     _mem_call_function+1
00014Cr 1  85 rr        	sta     ptr1+1
00014Er 1  AD rr rr     	lda     _mem_call_function
000151r 1  85 rr        	sta     ptr1
000153r 1  A0 00        	ldy     #$00
000155r 1  B1 rr        	lda     (ptr1),y
000157r 1  A0 02        	ldy     #$02
000159r 1  91 rr        	sta     (sp),y
00015Br 1               ;
00015Br 1               ; }
00015Br 1               ;
00015Br 1  4C rr rr     	jmp     incsp5
00015Er 1               
00015Er 1               .endproc
00015Er 1               
00015Er 1               ; ---------------------------------------------------------------
00015Er 1               ; void __near__ gfx_set_font_from_asset (unsigned char)
00015Er 1               ; ---------------------------------------------------------------
00015Er 1               
00015Er 1               .segment	"CODE"
00015Er 1               
00015Er 1               .proc	_gfx_set_font_from_asset: near
00015Er 1               
00015Er 1               .segment	"CODE"
00015Er 1               
00015Er 1               ;
00015Er 1               ; void     gfx_set_font_from_asset(uint8_t asset_id){
00015Er 1               ;
00015Er 1  20 rr rr     	jsr     pusha
000161r 1               ;
000161r 1               ; func_data = (call_gfx_set_font_from_asset_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000161r 1               ;
000161r 1  20 rr rr     	jsr     decsp3
000164r 1  A2 F1        	ldx     #$F1
000166r 1  A9 00        	lda     #$00
000168r 1  20 rr rr     	jsr     stax0sp
00016Br 1               ;
00016Br 1               ; func_data->hdr.func_type = 1;
00016Br 1               ;
00016Br 1  85 rr        	sta     ptr1
00016Dr 1  86 rr        	stx     ptr1+1
00016Fr 1  A9 01        	lda     #$01
000171r 1  A0 00        	ldy     #$00
000173r 1  91 rr        	sta     (ptr1),y
000175r 1               ;
000175r 1               ; func_data->hdr.func_id = 5;
000175r 1               ;
000175r 1  C8           	iny
000176r 1  B1 rr        	lda     (sp),y
000178r 1  85 rr        	sta     ptr1+1
00017Ar 1  88           	dey
00017Br 1  B1 rr        	lda     (sp),y
00017Dr 1  85 rr        	sta     ptr1
00017Fr 1  A9 05        	lda     #$05
000181r 1  C8           	iny
000182r 1  91 rr        	sta     (ptr1),y
000184r 1               ;
000184r 1               ; func_data->asset_id=asset_id;
000184r 1               ;
000184r 1  B1 rr        	lda     (sp),y
000186r 1  85 rr        	sta     ptr1+1
000188r 1  88           	dey
000189r 1  B1 rr        	lda     (sp),y
00018Br 1  85 rr        	sta     ptr1
00018Dr 1  A0 03        	ldy     #$03
00018Fr 1  B1 rr        	lda     (sp),y
000191r 1  88           	dey
000192r 1  91 rr        	sta     (ptr1),y
000194r 1               ;
000194r 1               ; result_code = *mem_call_function;
000194r 1               ;
000194r 1  AD rr rr     	lda     _mem_call_function+1
000197r 1  85 rr        	sta     ptr1+1
000199r 1  AD rr rr     	lda     _mem_call_function
00019Cr 1  85 rr        	sta     ptr1
00019Er 1  A0 00        	ldy     #$00
0001A0r 1  B1 rr        	lda     (ptr1),y
0001A2r 1  A0 02        	ldy     #$02
0001A4r 1  91 rr        	sta     (sp),y
0001A6r 1               ;
0001A6r 1               ; }
0001A6r 1               ;
0001A6r 1  4C rr rr     	jmp     incsp4
0001A9r 1               
0001A9r 1               .endproc
0001A9r 1               
0001A9r 1               ; ---------------------------------------------------------------
0001A9r 1               ; unsigned char __near__ gfx_get_pixel (unsigned int, unsigned int)
0001A9r 1               ; ---------------------------------------------------------------
0001A9r 1               
0001A9r 1               .segment	"CODE"
0001A9r 1               
0001A9r 1               .proc	_gfx_get_pixel: near
0001A9r 1               
0001A9r 1               .segment	"CODE"
0001A9r 1               
0001A9r 1               ;
0001A9r 1               ; uint8_t  gfx_get_pixel(uint16_t x, uint16_t y){
0001A9r 1               ;
0001A9r 1  20 rr rr     	jsr     pushax
0001ACr 1               ;
0001ACr 1               ; func_data = (call_gfx_get_pixel_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
0001ACr 1               ;
0001ACr 1  20 rr rr     	jsr     decsp3
0001AFr 1  A2 F1        	ldx     #$F1
0001B1r 1  A9 00        	lda     #$00
0001B3r 1  20 rr rr     	jsr     stax0sp
0001B6r 1               ;
0001B6r 1               ; func_data->hdr.func_type = 1;
0001B6r 1               ;
0001B6r 1  85 rr        	sta     ptr1
0001B8r 1  86 rr        	stx     ptr1+1
0001BAr 1  A9 01        	lda     #$01
0001BCr 1  A0 00        	ldy     #$00
0001BEr 1  91 rr        	sta     (ptr1),y
0001C0r 1               ;
0001C0r 1               ; func_data->hdr.func_id = 6;
0001C0r 1               ;
0001C0r 1  C8           	iny
0001C1r 1  B1 rr        	lda     (sp),y
0001C3r 1  85 rr        	sta     ptr1+1
0001C5r 1  88           	dey
0001C6r 1  B1 rr        	lda     (sp),y
0001C8r 1  85 rr        	sta     ptr1
0001CAr 1  A9 06        	lda     #$06
0001CCr 1  C8           	iny
0001CDr 1  91 rr        	sta     (ptr1),y
0001CFr 1               ;
0001CFr 1               ; func_data->x=x;
0001CFr 1               ;
0001CFr 1  B1 rr        	lda     (sp),y
0001D1r 1  85 rr        	sta     ptr1+1
0001D3r 1  88           	dey
0001D4r 1  B1 rr        	lda     (sp),y
0001D6r 1  85 rr        	sta     ptr1
0001D8r 1  A0 06        	ldy     #$06
0001DAr 1  B1 rr        	lda     (sp),y
0001DCr 1  AA           	tax
0001DDr 1  88           	dey
0001DEr 1  B1 rr        	lda     (sp),y
0001E0r 1  A0 02        	ldy     #$02
0001E2r 1  91 rr        	sta     (ptr1),y
0001E4r 1  C8           	iny
0001E5r 1  8A           	txa
0001E6r 1  91 rr        	sta     (ptr1),y
0001E8r 1               ;
0001E8r 1               ; func_data->y=y;
0001E8r 1               ;
0001E8r 1  A0 01        	ldy     #$01
0001EAr 1  B1 rr        	lda     (sp),y
0001ECr 1  85 rr        	sta     ptr1+1
0001EEr 1  88           	dey
0001EFr 1  B1 rr        	lda     (sp),y
0001F1r 1  85 rr        	sta     ptr1
0001F3r 1  A0 04        	ldy     #$04
0001F5r 1  B1 rr        	lda     (sp),y
0001F7r 1  AA           	tax
0001F8r 1  88           	dey
0001F9r 1  B1 rr        	lda     (sp),y
0001FBr 1  C8           	iny
0001FCr 1  91 rr        	sta     (ptr1),y
0001FEr 1  C8           	iny
0001FFr 1  8A           	txa
000200r 1  91 rr        	sta     (ptr1),y
000202r 1               ;
000202r 1               ; result_code = *mem_call_function;
000202r 1               ;
000202r 1  AD rr rr     	lda     _mem_call_function+1
000205r 1  85 rr        	sta     ptr1+1
000207r 1  AD rr rr     	lda     _mem_call_function
00020Ar 1  85 rr        	sta     ptr1
00020Cr 1  A0 00        	ldy     #$00
00020Er 1  B1 rr        	lda     (ptr1),y
000210r 1  A0 02        	ldy     #$02
000212r 1  91 rr        	sta     (sp),y
000214r 1               ;
000214r 1               ; uint8_t call_result = (uint8_t)*mem_call_result;
000214r 1               ;
000214r 1  AD rr rr     	lda     _mem_call_result+1
000217r 1  85 rr        	sta     ptr1+1
000219r 1  AD rr rr     	lda     _mem_call_result
00021Cr 1  85 rr        	sta     ptr1
00021Er 1  A0 00        	ldy     #$00
000220r 1  B1 rr        	lda     (ptr1),y
000222r 1  20 rr rr     	jsr     pusha
000225r 1               ;
000225r 1               ; return call_result;
000225r 1               ;
000225r 1  A2 00        	ldx     #$00
000227r 1  A1 rr        	lda     (sp,x)
000229r 1  20 rr rr     	jsr     incsp1
00022Cr 1               ;
00022Cr 1               ; }
00022Cr 1               ;
00022Cr 1  4C rr rr     	jmp     incsp7
00022Fr 1               
00022Fr 1               .endproc
00022Fr 1               
00022Fr 1               ; ---------------------------------------------------------------
00022Fr 1               ; void __near__ gfx_draw_pixel (unsigned int, unsigned int, unsigned char)
00022Fr 1               ; ---------------------------------------------------------------
00022Fr 1               
00022Fr 1               .segment	"CODE"
00022Fr 1               
00022Fr 1               .proc	_gfx_draw_pixel: near
00022Fr 1               
00022Fr 1               .segment	"CODE"
00022Fr 1               
00022Fr 1               ;
00022Fr 1               ; void     gfx_draw_pixel(uint16_t x, uint16_t y, uint8_t color_idx){
00022Fr 1               ;
00022Fr 1  20 rr rr     	jsr     pusha
000232r 1               ;
000232r 1               ; func_data = (call_gfx_draw_pixel_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000232r 1               ;
000232r 1  20 rr rr     	jsr     decsp3
000235r 1  A2 F1        	ldx     #$F1
000237r 1  A9 00        	lda     #$00
000239r 1  20 rr rr     	jsr     stax0sp
00023Cr 1               ;
00023Cr 1               ; func_data->hdr.func_type = 1;
00023Cr 1               ;
00023Cr 1  85 rr        	sta     ptr1
00023Er 1  86 rr        	stx     ptr1+1
000240r 1  A9 01        	lda     #$01
000242r 1  A0 00        	ldy     #$00
000244r 1  91 rr        	sta     (ptr1),y
000246r 1               ;
000246r 1               ; func_data->hdr.func_id = 7;
000246r 1               ;
000246r 1  C8           	iny
000247r 1  B1 rr        	lda     (sp),y
000249r 1  85 rr        	sta     ptr1+1
00024Br 1  88           	dey
00024Cr 1  B1 rr        	lda     (sp),y
00024Er 1  85 rr        	sta     ptr1
000250r 1  A9 07        	lda     #$07
000252r 1  C8           	iny
000253r 1  91 rr        	sta     (ptr1),y
000255r 1               ;
000255r 1               ; func_data->x=x;
000255r 1               ;
000255r 1  B1 rr        	lda     (sp),y
000257r 1  85 rr        	sta     ptr1+1
000259r 1  88           	dey
00025Ar 1  B1 rr        	lda     (sp),y
00025Cr 1  85 rr        	sta     ptr1
00025Er 1  A0 07        	ldy     #$07
000260r 1  B1 rr        	lda     (sp),y
000262r 1  AA           	tax
000263r 1  88           	dey
000264r 1  B1 rr        	lda     (sp),y
000266r 1  A0 02        	ldy     #$02
000268r 1  91 rr        	sta     (ptr1),y
00026Ar 1  C8           	iny
00026Br 1  8A           	txa
00026Cr 1  91 rr        	sta     (ptr1),y
00026Er 1               ;
00026Er 1               ; func_data->y=y;
00026Er 1               ;
00026Er 1  A0 01        	ldy     #$01
000270r 1  B1 rr        	lda     (sp),y
000272r 1  85 rr        	sta     ptr1+1
000274r 1  88           	dey
000275r 1  B1 rr        	lda     (sp),y
000277r 1  85 rr        	sta     ptr1
000279r 1  A0 05        	ldy     #$05
00027Br 1  B1 rr        	lda     (sp),y
00027Dr 1  AA           	tax
00027Er 1  88           	dey
00027Fr 1  B1 rr        	lda     (sp),y
000281r 1  91 rr        	sta     (ptr1),y
000283r 1  C8           	iny
000284r 1  8A           	txa
000285r 1  91 rr        	sta     (ptr1),y
000287r 1               ;
000287r 1               ; func_data->color_idx=color_idx;
000287r 1               ;
000287r 1  A0 01        	ldy     #$01
000289r 1  B1 rr        	lda     (sp),y
00028Br 1  85 rr        	sta     ptr1+1
00028Dr 1  88           	dey
00028Er 1  B1 rr        	lda     (sp),y
000290r 1  85 rr        	sta     ptr1
000292r 1  A0 03        	ldy     #$03
000294r 1  B1 rr        	lda     (sp),y
000296r 1  A0 06        	ldy     #$06
000298r 1  91 rr        	sta     (ptr1),y
00029Ar 1               ;
00029Ar 1               ; result_code = *mem_call_function;
00029Ar 1               ;
00029Ar 1  AD rr rr     	lda     _mem_call_function+1
00029Dr 1  85 rr        	sta     ptr1+1
00029Fr 1  AD rr rr     	lda     _mem_call_function
0002A2r 1  85 rr        	sta     ptr1
0002A4r 1  A0 00        	ldy     #$00
0002A6r 1  B1 rr        	lda     (ptr1),y
0002A8r 1  A0 02        	ldy     #$02
0002AAr 1  91 rr        	sta     (sp),y
0002ACr 1               ;
0002ACr 1               ; }
0002ACr 1               ;
0002ACr 1  4C rr rr     	jmp     incsp8
0002AFr 1               
0002AFr 1               .endproc
0002AFr 1               
0002AFr 1               ; ---------------------------------------------------------------
0002AFr 1               ; void __near__ gfx_draw_char (unsigned int, unsigned int, unsigned char, unsigned char)
0002AFr 1               ; ---------------------------------------------------------------
0002AFr 1               
0002AFr 1               .segment	"CODE"
0002AFr 1               
0002AFr 1               .proc	_gfx_draw_char: near
0002AFr 1               
0002AFr 1               .segment	"CODE"
0002AFr 1               
0002AFr 1               ;
0002AFr 1               ; void     gfx_draw_char(uint16_t x, uint16_t y, char ch, uint8_t color_idx){
0002AFr 1               ;
0002AFr 1  20 rr rr     	jsr     pusha
0002B2r 1               ;
0002B2r 1               ; func_data = (call_gfx_draw_char_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
0002B2r 1               ;
0002B2r 1  20 rr rr     	jsr     decsp3
0002B5r 1  A2 F1        	ldx     #$F1
0002B7r 1  A9 00        	lda     #$00
0002B9r 1  20 rr rr     	jsr     stax0sp
0002BCr 1               ;
0002BCr 1               ; func_data->hdr.func_type = 1;
0002BCr 1               ;
0002BCr 1  85 rr        	sta     ptr1
0002BEr 1  86 rr        	stx     ptr1+1
0002C0r 1  A9 01        	lda     #$01
0002C2r 1  A0 00        	ldy     #$00
0002C4r 1  91 rr        	sta     (ptr1),y
0002C6r 1               ;
0002C6r 1               ; func_data->hdr.func_id = 8;
0002C6r 1               ;
0002C6r 1  C8           	iny
0002C7r 1  B1 rr        	lda     (sp),y
0002C9r 1  85 rr        	sta     ptr1+1
0002CBr 1  88           	dey
0002CCr 1  B1 rr        	lda     (sp),y
0002CEr 1  85 rr        	sta     ptr1
0002D0r 1  A9 08        	lda     #$08
0002D2r 1  C8           	iny
0002D3r 1  91 rr        	sta     (ptr1),y
0002D5r 1               ;
0002D5r 1               ; func_data->x=x;
0002D5r 1               ;
0002D5r 1  B1 rr        	lda     (sp),y
0002D7r 1  85 rr        	sta     ptr1+1
0002D9r 1  88           	dey
0002DAr 1  B1 rr        	lda     (sp),y
0002DCr 1  85 rr        	sta     ptr1
0002DEr 1  A0 08        	ldy     #$08
0002E0r 1  B1 rr        	lda     (sp),y
0002E2r 1  AA           	tax
0002E3r 1  88           	dey
0002E4r 1  B1 rr        	lda     (sp),y
0002E6r 1  A0 02        	ldy     #$02
0002E8r 1  91 rr        	sta     (ptr1),y
0002EAr 1  C8           	iny
0002EBr 1  8A           	txa
0002ECr 1  91 rr        	sta     (ptr1),y
0002EEr 1               ;
0002EEr 1               ; func_data->y=y;
0002EEr 1               ;
0002EEr 1  A0 01        	ldy     #$01
0002F0r 1  B1 rr        	lda     (sp),y
0002F2r 1  85 rr        	sta     ptr1+1
0002F4r 1  88           	dey
0002F5r 1  B1 rr        	lda     (sp),y
0002F7r 1  85 rr        	sta     ptr1
0002F9r 1  A0 06        	ldy     #$06
0002FBr 1  B1 rr        	lda     (sp),y
0002FDr 1  AA           	tax
0002FEr 1  88           	dey
0002FFr 1  B1 rr        	lda     (sp),y
000301r 1  88           	dey
000302r 1  91 rr        	sta     (ptr1),y
000304r 1  C8           	iny
000305r 1  8A           	txa
000306r 1  91 rr        	sta     (ptr1),y
000308r 1               ;
000308r 1               ; func_data->ch=ch;
000308r 1               ;
000308r 1  A0 01        	ldy     #$01
00030Ar 1  B1 rr        	lda     (sp),y
00030Cr 1  85 rr        	sta     ptr1+1
00030Er 1  88           	dey
00030Fr 1  B1 rr        	lda     (sp),y
000311r 1  85 rr        	sta     ptr1
000313r 1  A0 04        	ldy     #$04
000315r 1  B1 rr        	lda     (sp),y
000317r 1  A0 06        	ldy     #$06
000319r 1  91 rr        	sta     (ptr1),y
00031Br 1               ;
00031Br 1               ; func_data->color_idx=color_idx;
00031Br 1               ;
00031Br 1  A0 01        	ldy     #$01
00031Dr 1  B1 rr        	lda     (sp),y
00031Fr 1  85 rr        	sta     ptr1+1
000321r 1  88           	dey
000322r 1  B1 rr        	lda     (sp),y
000324r 1  85 rr        	sta     ptr1
000326r 1  A0 03        	ldy     #$03
000328r 1  B1 rr        	lda     (sp),y
00032Ar 1  A0 07        	ldy     #$07
00032Cr 1  91 rr        	sta     (ptr1),y
00032Er 1               ;
00032Er 1               ; result_code = *mem_call_function;
00032Er 1               ;
00032Er 1  AD rr rr     	lda     _mem_call_function+1
000331r 1  85 rr        	sta     ptr1+1
000333r 1  AD rr rr     	lda     _mem_call_function
000336r 1  85 rr        	sta     ptr1
000338r 1  A0 00        	ldy     #$00
00033Ar 1  B1 rr        	lda     (ptr1),y
00033Cr 1  A0 02        	ldy     #$02
00033Er 1  91 rr        	sta     (sp),y
000340r 1               ;
000340r 1               ; }
000340r 1               ;
000340r 1  A0 09        	ldy     #$09
000342r 1  4C rr rr     	jmp     addysp
000345r 1               
000345r 1               .endproc
000345r 1               
000345r 1               ; ---------------------------------------------------------------
000345r 1               ; unsigned char __near__ io_keyboard_is_pressed (unsigned char)
000345r 1               ; ---------------------------------------------------------------
000345r 1               
000345r 1               .segment	"CODE"
000345r 1               
000345r 1               .proc	_io_keyboard_is_pressed: near
000345r 1               
000345r 1               .segment	"CODE"
000345r 1               
000345r 1               ;
000345r 1               ; bool io_keyboard_is_pressed(uint8_t keycode){
000345r 1               ;
000345r 1  20 rr rr     	jsr     pusha
000348r 1               ;
000348r 1               ; func_data = (call_io_keyboard_is_pressed_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000348r 1               ;
000348r 1  20 rr rr     	jsr     decsp3
00034Br 1  A2 F1        	ldx     #$F1
00034Dr 1  A9 00        	lda     #$00
00034Fr 1  20 rr rr     	jsr     stax0sp
000352r 1               ;
000352r 1               ; func_data->hdr.func_type = 2;
000352r 1               ;
000352r 1  85 rr        	sta     ptr1
000354r 1  86 rr        	stx     ptr1+1
000356r 1  A9 02        	lda     #$02
000358r 1  A0 00        	ldy     #$00
00035Ar 1  91 rr        	sta     (ptr1),y
00035Cr 1               ;
00035Cr 1               ; func_data->hdr.func_id = 1;
00035Cr 1               ;
00035Cr 1  C8           	iny
00035Dr 1  B1 rr        	lda     (sp),y
00035Fr 1  85 rr        	sta     ptr1+1
000361r 1  88           	dey
000362r 1  B1 rr        	lda     (sp),y
000364r 1  85 rr        	sta     ptr1
000366r 1  A9 01        	lda     #$01
000368r 1  C8           	iny
000369r 1  91 rr        	sta     (ptr1),y
00036Br 1               ;
00036Br 1               ; func_data->keycode=keycode;
00036Br 1               ;
00036Br 1  B1 rr        	lda     (sp),y
00036Dr 1  85 rr        	sta     ptr1+1
00036Fr 1  88           	dey
000370r 1  B1 rr        	lda     (sp),y
000372r 1  85 rr        	sta     ptr1
000374r 1  A0 03        	ldy     #$03
000376r 1  B1 rr        	lda     (sp),y
000378r 1  88           	dey
000379r 1  91 rr        	sta     (ptr1),y
00037Br 1               ;
00037Br 1               ; result_code = *mem_call_function;
00037Br 1               ;
00037Br 1  AD rr rr     	lda     _mem_call_function+1
00037Er 1  85 rr        	sta     ptr1+1
000380r 1  AD rr rr     	lda     _mem_call_function
000383r 1  85 rr        	sta     ptr1
000385r 1  A0 00        	ldy     #$00
000387r 1  B1 rr        	lda     (ptr1),y
000389r 1  A0 02        	ldy     #$02
00038Br 1  91 rr        	sta     (sp),y
00038Dr 1               ;
00038Dr 1               ; bool call_result = (bool)*mem_call_result;
00038Dr 1               ;
00038Dr 1  AD rr rr     	lda     _mem_call_result+1
000390r 1  85 rr        	sta     ptr1+1
000392r 1  AD rr rr     	lda     _mem_call_result
000395r 1  85 rr        	sta     ptr1
000397r 1  A0 00        	ldy     #$00
000399r 1  B1 rr        	lda     (ptr1),y
00039Br 1  20 rr rr     	jsr     pusha
00039Er 1               ;
00039Er 1               ; return call_result;
00039Er 1               ;
00039Er 1  A2 00        	ldx     #$00
0003A0r 1  A1 rr        	lda     (sp,x)
0003A2r 1  20 rr rr     	jsr     incsp1
0003A5r 1               ;
0003A5r 1               ; }
0003A5r 1               ;
0003A5r 1  4C rr rr     	jmp     incsp4
0003A8r 1               
0003A8r 1               .endproc
0003A8r 1               
0003A8r 1               ; ---------------------------------------------------------------
0003A8r 1               ; unsigned char __near__ io_keyboard_is_down (unsigned char)
0003A8r 1               ; ---------------------------------------------------------------
0003A8r 1               
0003A8r 1               .segment	"CODE"
0003A8r 1               
0003A8r 1               .proc	_io_keyboard_is_down: near
0003A8r 1               
0003A8r 1               .segment	"CODE"
0003A8r 1               
0003A8r 1               ;
0003A8r 1               ; bool io_keyboard_is_down(uint8_t keycode){
0003A8r 1               ;
0003A8r 1  20 rr rr     	jsr     pusha
0003ABr 1               ;
0003ABr 1               ; func_data = (call_io_keyboard_is_down_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
0003ABr 1               ;
0003ABr 1  20 rr rr     	jsr     decsp3
0003AEr 1  A2 F1        	ldx     #$F1
0003B0r 1  A9 00        	lda     #$00
0003B2r 1  20 rr rr     	jsr     stax0sp
0003B5r 1               ;
0003B5r 1               ; func_data->hdr.func_type = 2;
0003B5r 1               ;
0003B5r 1  85 rr        	sta     ptr1
0003B7r 1  86 rr        	stx     ptr1+1
0003B9r 1  A9 02        	lda     #$02
0003BBr 1  A0 00        	ldy     #$00
0003BDr 1  91 rr        	sta     (ptr1),y
0003BFr 1               ;
0003BFr 1               ; func_data->hdr.func_id = 2;
0003BFr 1               ;
0003BFr 1  C8           	iny
0003C0r 1  B1 rr        	lda     (sp),y
0003C2r 1  85 rr        	sta     ptr1+1
0003C4r 1  88           	dey
0003C5r 1  B1 rr        	lda     (sp),y
0003C7r 1  85 rr        	sta     ptr1
0003C9r 1  A9 02        	lda     #$02
0003CBr 1  C8           	iny
0003CCr 1  91 rr        	sta     (ptr1),y
0003CEr 1               ;
0003CEr 1               ; func_data->keycode=keycode;
0003CEr 1               ;
0003CEr 1  B1 rr        	lda     (sp),y
0003D0r 1  85 rr        	sta     ptr1+1
0003D2r 1  88           	dey
0003D3r 1  B1 rr        	lda     (sp),y
0003D5r 1  85 rr        	sta     ptr1
0003D7r 1  A0 03        	ldy     #$03
0003D9r 1  B1 rr        	lda     (sp),y
0003DBr 1  88           	dey
0003DCr 1  91 rr        	sta     (ptr1),y
0003DEr 1               ;
0003DEr 1               ; result_code = *mem_call_function;
0003DEr 1               ;
0003DEr 1  AD rr rr     	lda     _mem_call_function+1
0003E1r 1  85 rr        	sta     ptr1+1
0003E3r 1  AD rr rr     	lda     _mem_call_function
0003E6r 1  85 rr        	sta     ptr1
0003E8r 1  A0 00        	ldy     #$00
0003EAr 1  B1 rr        	lda     (ptr1),y
0003ECr 1  A0 02        	ldy     #$02
0003EEr 1  91 rr        	sta     (sp),y
0003F0r 1               ;
0003F0r 1               ; bool call_result = (bool)*mem_call_result;
0003F0r 1               ;
0003F0r 1  AD rr rr     	lda     _mem_call_result+1
0003F3r 1  85 rr        	sta     ptr1+1
0003F5r 1  AD rr rr     	lda     _mem_call_result
0003F8r 1  85 rr        	sta     ptr1
0003FAr 1  A0 00        	ldy     #$00
0003FCr 1  B1 rr        	lda     (ptr1),y
0003FEr 1  20 rr rr     	jsr     pusha
000401r 1               ;
000401r 1               ; return call_result;
000401r 1               ;
000401r 1  A2 00        	ldx     #$00
000403r 1  A1 rr        	lda     (sp,x)
000405r 1  20 rr rr     	jsr     incsp1
000408r 1               ;
000408r 1               ; }
000408r 1               ;
000408r 1  4C rr rr     	jmp     incsp4
00040Br 1               
00040Br 1               .endproc
00040Br 1               
00040Br 1               ; ---------------------------------------------------------------
00040Br 1               ; unsigned char __near__ io_keyboard_is_released (unsigned char)
00040Br 1               ; ---------------------------------------------------------------
00040Br 1               
00040Br 1               .segment	"CODE"
00040Br 1               
00040Br 1               .proc	_io_keyboard_is_released: near
00040Br 1               
00040Br 1               .segment	"CODE"
00040Br 1               
00040Br 1               ;
00040Br 1               ; bool io_keyboard_is_released(uint8_t keycode){
00040Br 1               ;
00040Br 1  20 rr rr     	jsr     pusha
00040Er 1               ;
00040Er 1               ; func_data = (call_io_keyboard_is_released_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00040Er 1               ;
00040Er 1  20 rr rr     	jsr     decsp3
000411r 1  A2 F1        	ldx     #$F1
000413r 1  A9 00        	lda     #$00
000415r 1  20 rr rr     	jsr     stax0sp
000418r 1               ;
000418r 1               ; func_data->hdr.func_type = 2;
000418r 1               ;
000418r 1  85 rr        	sta     ptr1
00041Ar 1  86 rr        	stx     ptr1+1
00041Cr 1  A9 02        	lda     #$02
00041Er 1  A0 00        	ldy     #$00
000420r 1  91 rr        	sta     (ptr1),y
000422r 1               ;
000422r 1               ; func_data->hdr.func_id = 3;
000422r 1               ;
000422r 1  C8           	iny
000423r 1  B1 rr        	lda     (sp),y
000425r 1  85 rr        	sta     ptr1+1
000427r 1  88           	dey
000428r 1  B1 rr        	lda     (sp),y
00042Ar 1  85 rr        	sta     ptr1
00042Cr 1  A9 03        	lda     #$03
00042Er 1  C8           	iny
00042Fr 1  91 rr        	sta     (ptr1),y
000431r 1               ;
000431r 1               ; func_data->keycode=keycode;
000431r 1               ;
000431r 1  B1 rr        	lda     (sp),y
000433r 1  85 rr        	sta     ptr1+1
000435r 1  88           	dey
000436r 1  B1 rr        	lda     (sp),y
000438r 1  85 rr        	sta     ptr1
00043Ar 1  A0 03        	ldy     #$03
00043Cr 1  B1 rr        	lda     (sp),y
00043Er 1  88           	dey
00043Fr 1  91 rr        	sta     (ptr1),y
000441r 1               ;
000441r 1               ; result_code = *mem_call_function;
000441r 1               ;
000441r 1  AD rr rr     	lda     _mem_call_function+1
000444r 1  85 rr        	sta     ptr1+1
000446r 1  AD rr rr     	lda     _mem_call_function
000449r 1  85 rr        	sta     ptr1
00044Br 1  A0 00        	ldy     #$00
00044Dr 1  B1 rr        	lda     (ptr1),y
00044Fr 1  A0 02        	ldy     #$02
000451r 1  91 rr        	sta     (sp),y
000453r 1               ;
000453r 1               ; bool call_result = (bool)*mem_call_result;
000453r 1               ;
000453r 1  AD rr rr     	lda     _mem_call_result+1
000456r 1  85 rr        	sta     ptr1+1
000458r 1  AD rr rr     	lda     _mem_call_result
00045Br 1  85 rr        	sta     ptr1
00045Dr 1  A0 00        	ldy     #$00
00045Fr 1  B1 rr        	lda     (ptr1),y
000461r 1  20 rr rr     	jsr     pusha
000464r 1               ;
000464r 1               ; return call_result;
000464r 1               ;
000464r 1  A2 00        	ldx     #$00
000466r 1  A1 rr        	lda     (sp,x)
000468r 1  20 rr rr     	jsr     incsp1
00046Br 1               ;
00046Br 1               ; }
00046Br 1               ;
00046Br 1  4C rr rr     	jmp     incsp4
00046Er 1               
00046Er 1               .endproc
00046Er 1               
00046Er 1               ; ---------------------------------------------------------------
00046Er 1               ; int __near__ main (void)
00046Er 1               ; ---------------------------------------------------------------
00046Er 1               
00046Er 1               .segment	"CODE"
00046Er 1               
00046Er 1               .proc	_main: near
00046Er 1               
00046Er 1               .segment	"CODE"
00046Er 1               
00046Er 1               ;
00046Er 1               ; uint8_t* tile_map = (uint8_t*)MEMORY_TILEAREA_BEGIN;
00046Er 1               ;
00046Er 1  20 rr rr     	jsr     decsp3
000471r 1  A2 F1        	ldx     #$F1
000473r 1  A9 0B        	lda     #$0B
000475r 1  20 rr rr     	jsr     pushax
000478r 1               ;
000478r 1               ; volatile uint16_t* mouse_x = (uint16_t*)MM_MOUSE_X;
000478r 1               ;
000478r 1  20 rr rr     	jsr     decsp1
00047Br 1  CA           	dex
00047Cr 1  A9 02        	lda     #$02
00047Er 1  20 rr rr     	jsr     pushax
000481r 1               ;
000481r 1               ; volatile uint16_t* mouse_y = (uint16_t*)MM_MOUSE_Y;
000481r 1               ;
000481r 1  A9 04        	lda     #$04
000483r 1  20 rr rr     	jsr     pushax
000486r 1               ;
000486r 1               ; palette = ASSET_COLOR_PALETTE;
000486r 1               ;
000486r 1  20 rr rr     	jsr     decsp1
000489r 1  A9 00        	lda     #$00
00048Br 1  A8           	tay
00048Cr 1  91 rr        	sta     (sp),y
00048Er 1               ;
00048Er 1               ; timer = 0;
00048Er 1               ;
00048Er 1  A0 0A        	ldy     #$0A
000490r 1  91 rr        	sta     (sp),y
000492r 1               ;
000492r 1               ; rows = 0;
000492r 1               ;
000492r 1  A0 08        	ldy     #$08
000494r 1  91 rr        	sta     (sp),y
000496r 1               ;
000496r 1               ; pos_x = 0;
000496r 1               ;
000496r 1  C8           	iny
000497r 1  91 rr        	sta     (sp),y
000499r 1               ;
000499r 1               ; gfx_set_palette_from_assset(ASSET_COLOR_PALETTE,2);
000499r 1               ;
000499r 1  20 rr rr     	jsr     pusha
00049Cr 1  A9 02        	lda     #$02
00049Er 1  20 rr rr     	jsr     _gfx_set_palette_from_assset
0004A1r 1               ;
0004A1r 1               ; uint8_t x = *mouse_x / 8;
0004A1r 1               ;
0004A1r 1  A0 04        L00B2:	ldy     #$04
0004A3r 1  B1 rr        	lda     (sp),y
0004A5r 1  85 rr        	sta     ptr1+1
0004A7r 1  88           	dey
0004A8r 1  B1 rr        	lda     (sp),y
0004AAr 1  85 rr        	sta     ptr1
0004ACr 1  A0 01        	ldy     #$01
0004AEr 1  B1 rr        	lda     (ptr1),y
0004B0r 1  AA           	tax
0004B1r 1  88           	dey
0004B2r 1  B1 rr        	lda     (ptr1),y
0004B4r 1  20 rr rr     	jsr     shrax3
0004B7r 1  20 rr rr     	jsr     pusha
0004BAr 1               ;
0004BAr 1               ; uint8_t y = *mouse_y / 8;
0004BAr 1               ;
0004BAr 1  A0 03        	ldy     #$03
0004BCr 1  B1 rr        	lda     (sp),y
0004BEr 1  85 rr        	sta     ptr1+1
0004C0r 1  88           	dey
0004C1r 1  B1 rr        	lda     (sp),y
0004C3r 1  85 rr        	sta     ptr1
0004C5r 1  88           	dey
0004C6r 1  B1 rr        	lda     (ptr1),y
0004C8r 1  AA           	tax
0004C9r 1  88           	dey
0004CAr 1  B1 rr        	lda     (ptr1),y
0004CCr 1  20 rr rr     	jsr     shrax3
0004CFr 1  20 rr rr     	jsr     pusha
0004D2r 1               ;
0004D2r 1               ; *(tile_map+y*40+x)=col++;
0004D2r 1               ;
0004D2r 1  A0 0B        	ldy     #$0B
0004D4r 1  20 rr rr     	jsr     pushwysp
0004D7r 1  A0 02        	ldy     #$02
0004D9r 1  B1 rr        	lda     (sp),y
0004DBr 1  20 rr rr     	jsr     pusha0
0004DEr 1  A9 28        	lda     #$28
0004E0r 1  20 rr rr     	jsr     tosumula0
0004E3r 1  20 rr rr     	jsr     tosaddax
0004E6r 1  85 rr        	sta     ptr1
0004E8r 1  86 rr        	stx     ptr1+1
0004EAr 1  A0 01        	ldy     #$01
0004ECr 1  B1 rr        	lda     (sp),y
0004EEr 1  18           	clc
0004EFr 1  65 rr        	adc     ptr1
0004F1r 1  A6 rr        	ldx     ptr1+1
0004F3r 1  90 01        	bcc     L00BC
0004F5r 1  E8           	inx
0004F6r 1  20 rr rr     L00BC:	jsr     pushax
0004F9r 1  A0 09        	ldy     #$09
0004FBr 1  B1 rr        	lda     (sp),y
0004FDr 1  48           	pha
0004FEr 1  18           	clc
0004FFr 1  69 01        	adc     #$01
000501r 1  91 rr        	sta     (sp),y
000503r 1  68           	pla
000504r 1  A0 00        	ldy     #$00
000506r 1  20 rr rr     	jsr     staspidx
000509r 1               ;
000509r 1               ; }
000509r 1               ;
000509r 1  20 rr rr     	jsr     incsp2
00050Cr 1               ;
00050Cr 1               ; while (1){
00050Cr 1               ;
00050Cr 1  4C rr rr     	jmp     L00B2
00050Fr 1               
00050Fr 1               .endproc
00050Fr 1               
00050Fr 1               
