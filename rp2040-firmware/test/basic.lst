ca65 V2.18 - Ubuntu 2.19-1
Main file   : 6502_func_call_api.s
Current file: 6502_func_call_api.s

000000r 1               ;
000000r 1               ; File generated by cc65 v 2.18 - Ubuntu 2.19-1
000000r 1               ;
000000r 1               	.fopt		compiler,"cc65 v 2.18 - Ubuntu 2.19-1"
000000r 1               	.setcpu		"6502"
000000r 1               	.smart		on
000000r 1               	.autoimport	on
000000r 1               	.case		on
000000r 1               	.debuginfo	off
000000r 1               	.importzp	sp, sreg, regsave, regbank
000000r 1               	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
000000r 1               	.macpack	longbranch
000000r 2               .macro  jeq     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                       bne     *+5
000000r 2                       jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               beq     Target
000000r 2                       .else
000000r 2                               bne     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jne     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bne     Target
000000r 2                       .else
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jmi     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bmi     Target
000000r 2                       .else
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jpl     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bpl     Target
000000r 2                       .else
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcs     Target
000000r 2                       .else
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcc     Target
000000r 2                       .else
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvs     Target
000000r 2                       .else
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvc     Target
000000r 2                       .else
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 1               	.forceimport	__STARTUP__
000000r 1               	.export		_gfx_renderqueue_apply
000000r 1               	.export		_gfx_set_palettecolor
000000r 1               	.export		_gfx_get_palettecolor
000000r 1               	.export		_gfx_set_palette_from_assset
000000r 1               	.export		_gfx_set_font_from_asset
000000r 1               	.export		_gfx_get_pixel
000000r 1               	.export		_gfx_draw_pixel
000000r 1               	.export		_gfx_draw_char
000000r 1               	.export		_io_keyboard_is_pressed
000000r 1               	.export		_io_keyboard_is_down
000000r 1               	.export		_io_keyboard_is_released
000000r 1               	.export		_call_function
000000r 1               	.export		_main
000000r 1               
000000r 1               .segment	"DATA"
000000r 1               
000000r 1               _call_function:
000000r 1  08 F0        	.word	$F008
000002r 1               
000002r 1               ; ---------------------------------------------------------------
000002r 1               ; void __near__ gfx_renderqueue_apply (void)
000002r 1               ; ---------------------------------------------------------------
000002r 1               
000002r 1               .segment	"CODE"
000000r 1               
000000r 1               .proc	_gfx_renderqueue_apply: near
000000r 1               
000000r 1               .segment	"CODE"
000000r 1               
000000r 1               ;
000000r 1               ; func_data = (call_gfx_renderqueue_apply_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000000r 1               ;
000000r 1  20 rr rr     	jsr     decsp3
000003r 1  A2 F1        	ldx     #$F1
000005r 1  A9 00        	lda     #$00
000007r 1  20 rr rr     	jsr     stax0sp
00000Ar 1               ;
00000Ar 1               ; func_data->hdr.func_type = 1;
00000Ar 1               ;
00000Ar 1  85 rr        	sta     ptr1
00000Cr 1  86 rr        	stx     ptr1+1
00000Er 1  A9 01        	lda     #$01
000010r 1  A0 00        	ldy     #$00
000012r 1  91 rr        	sta     (ptr1),y
000014r 1               ;
000014r 1               ; func_data->hdr.func_id = 1;
000014r 1               ;
000014r 1  C8           	iny
000015r 1  B1 rr        	lda     (sp),y
000017r 1  85 rr        	sta     ptr1+1
000019r 1  88           	dey
00001Ar 1  B1 rr        	lda     (sp),y
00001Cr 1  85 rr        	sta     ptr1
00001Er 1  A9 01        	lda     #$01
000020r 1  C8           	iny
000021r 1  91 rr        	sta     (ptr1),y
000023r 1               ;
000023r 1               ; result_code = *call_function;
000023r 1               ;
000023r 1  AD rr rr     	lda     _call_function+1
000026r 1  85 rr        	sta     ptr1+1
000028r 1  AD rr rr     	lda     _call_function
00002Br 1  85 rr        	sta     ptr1
00002Dr 1  88           	dey
00002Er 1  B1 rr        	lda     (ptr1),y
000030r 1  A0 02        	ldy     #$02
000032r 1  91 rr        	sta     (sp),y
000034r 1               ;
000034r 1               ; }
000034r 1               ;
000034r 1  4C rr rr     	jmp     incsp3
000037r 1               
000037r 1               .endproc
000037r 1               
000037r 1               ; ---------------------------------------------------------------
000037r 1               ; void __near__ gfx_set_palettecolor (unsigned char, unsigned int)
000037r 1               ; ---------------------------------------------------------------
000037r 1               
000037r 1               .segment	"CODE"
000037r 1               
000037r 1               .proc	_gfx_set_palettecolor: near
000037r 1               
000037r 1               .segment	"CODE"
000037r 1               
000037r 1               ;
000037r 1               ; void     gfx_set_palettecolor(uint8_t color_idx, uint16_t color565){
000037r 1               ;
000037r 1  20 rr rr     	jsr     pushax
00003Ar 1               ;
00003Ar 1               ; func_data = (call_gfx_set_palettecolor_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00003Ar 1               ;
00003Ar 1  20 rr rr     	jsr     decsp3
00003Dr 1  A2 F1        	ldx     #$F1
00003Fr 1  A9 00        	lda     #$00
000041r 1  20 rr rr     	jsr     stax0sp
000044r 1               ;
000044r 1               ; func_data->hdr.func_type = 1;
000044r 1               ;
000044r 1  85 rr        	sta     ptr1
000046r 1  86 rr        	stx     ptr1+1
000048r 1  A9 01        	lda     #$01
00004Ar 1  A0 00        	ldy     #$00
00004Cr 1  91 rr        	sta     (ptr1),y
00004Er 1               ;
00004Er 1               ; func_data->hdr.func_id = 2;
00004Er 1               ;
00004Er 1  C8           	iny
00004Fr 1  B1 rr        	lda     (sp),y
000051r 1  85 rr        	sta     ptr1+1
000053r 1  88           	dey
000054r 1  B1 rr        	lda     (sp),y
000056r 1  85 rr        	sta     ptr1
000058r 1  A9 02        	lda     #$02
00005Ar 1  C8           	iny
00005Br 1  91 rr        	sta     (ptr1),y
00005Dr 1               ;
00005Dr 1               ; func_data->color_idx=color_idx;
00005Dr 1               ;
00005Dr 1  B1 rr        	lda     (sp),y
00005Fr 1  85 rr        	sta     ptr1+1
000061r 1  88           	dey
000062r 1  B1 rr        	lda     (sp),y
000064r 1  85 rr        	sta     ptr1
000066r 1  A0 05        	ldy     #$05
000068r 1  B1 rr        	lda     (sp),y
00006Ar 1  A0 02        	ldy     #$02
00006Cr 1  91 rr        	sta     (ptr1),y
00006Er 1               ;
00006Er 1               ; func_data->color565=color565;
00006Er 1               ;
00006Er 1  88           	dey
00006Fr 1  B1 rr        	lda     (sp),y
000071r 1  85 rr        	sta     ptr1+1
000073r 1  88           	dey
000074r 1  B1 rr        	lda     (sp),y
000076r 1  85 rr        	sta     ptr1
000078r 1  A0 04        	ldy     #$04
00007Ar 1  B1 rr        	lda     (sp),y
00007Cr 1  AA           	tax
00007Dr 1  88           	dey
00007Er 1  B1 rr        	lda     (sp),y
000080r 1  91 rr        	sta     (ptr1),y
000082r 1  C8           	iny
000083r 1  8A           	txa
000084r 1  91 rr        	sta     (ptr1),y
000086r 1               ;
000086r 1               ; result_code = *call_function;
000086r 1               ;
000086r 1  AD rr rr     	lda     _call_function+1
000089r 1  85 rr        	sta     ptr1+1
00008Br 1  AD rr rr     	lda     _call_function
00008Er 1  85 rr        	sta     ptr1
000090r 1  A0 00        	ldy     #$00
000092r 1  B1 rr        	lda     (ptr1),y
000094r 1  A0 02        	ldy     #$02
000096r 1  91 rr        	sta     (sp),y
000098r 1               ;
000098r 1               ; }
000098r 1               ;
000098r 1  4C rr rr     	jmp     incsp6
00009Br 1               
00009Br 1               .endproc
00009Br 1               
00009Br 1               ; ---------------------------------------------------------------
00009Br 1               ; unsigned int __near__ gfx_get_palettecolor (unsigned char)
00009Br 1               ; ---------------------------------------------------------------
00009Br 1               
00009Br 1               .segment	"CODE"
00009Br 1               
00009Br 1               .proc	_gfx_get_palettecolor: near
00009Br 1               
00009Br 1               .segment	"CODE"
00009Br 1               
00009Br 1               ;
00009Br 1               ; uint16_t gfx_get_palettecolor(uint8_t color_idx){
00009Br 1               ;
00009Br 1  20 rr rr     	jsr     pusha
00009Er 1               ;
00009Er 1               ; func_data = (call_gfx_get_palettecolor_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00009Er 1               ;
00009Er 1  20 rr rr     	jsr     decsp3
0000A1r 1  A2 F1        	ldx     #$F1
0000A3r 1  A9 00        	lda     #$00
0000A5r 1  20 rr rr     	jsr     stax0sp
0000A8r 1               ;
0000A8r 1               ; func_data->hdr.func_type = 1;
0000A8r 1               ;
0000A8r 1  85 rr        	sta     ptr1
0000AAr 1  86 rr        	stx     ptr1+1
0000ACr 1  A9 01        	lda     #$01
0000AEr 1  A0 00        	ldy     #$00
0000B0r 1  91 rr        	sta     (ptr1),y
0000B2r 1               ;
0000B2r 1               ; func_data->hdr.func_id = 3;
0000B2r 1               ;
0000B2r 1  C8           	iny
0000B3r 1  B1 rr        	lda     (sp),y
0000B5r 1  85 rr        	sta     ptr1+1
0000B7r 1  88           	dey
0000B8r 1  B1 rr        	lda     (sp),y
0000BAr 1  85 rr        	sta     ptr1
0000BCr 1  A9 03        	lda     #$03
0000BEr 1  C8           	iny
0000BFr 1  91 rr        	sta     (ptr1),y
0000C1r 1               ;
0000C1r 1               ; func_data->color_idx=color_idx;
0000C1r 1               ;
0000C1r 1  B1 rr        	lda     (sp),y
0000C3r 1  85 rr        	sta     ptr1+1
0000C5r 1  88           	dey
0000C6r 1  B1 rr        	lda     (sp),y
0000C8r 1  85 rr        	sta     ptr1
0000CAr 1  A0 03        	ldy     #$03
0000CCr 1  B1 rr        	lda     (sp),y
0000CEr 1  88           	dey
0000CFr 1  91 rr        	sta     (ptr1),y
0000D1r 1               ;
0000D1r 1               ; result_code = *call_function;
0000D1r 1               ;
0000D1r 1  AD rr rr     	lda     _call_function+1
0000D4r 1  85 rr        	sta     ptr1+1
0000D6r 1  AD rr rr     	lda     _call_function
0000D9r 1  85 rr        	sta     ptr1
0000DBr 1  A0 00        	ldy     #$00
0000DDr 1  B1 rr        	lda     (ptr1),y
0000DFr 1  A0 02        	ldy     #$02
0000E1r 1  91 rr        	sta     (sp),y
0000E3r 1               ;
0000E3r 1               ; return *((uint16_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN));
0000E3r 1               ;
0000E3r 1  AD 00 F1     	lda     $F100
0000E6r 1  AE 01 F1     	ldx     $F100+1
0000E9r 1               ;
0000E9r 1               ; }
0000E9r 1               ;
0000E9r 1  4C rr rr     	jmp     incsp4
0000ECr 1               
0000ECr 1               .endproc
0000ECr 1               
0000ECr 1               ; ---------------------------------------------------------------
0000ECr 1               ; void __near__ gfx_set_palette_from_assset (unsigned char, unsigned char)
0000ECr 1               ; ---------------------------------------------------------------
0000ECr 1               
0000ECr 1               .segment	"CODE"
0000ECr 1               
0000ECr 1               .proc	_gfx_set_palette_from_assset: near
0000ECr 1               
0000ECr 1               .segment	"CODE"
0000ECr 1               
0000ECr 1               ;
0000ECr 1               ; void     gfx_set_palette_from_assset(uint8_t asset_id, uint8_t fill_unused_with_idx){
0000ECr 1               ;
0000ECr 1  20 rr rr     	jsr     pusha
0000EFr 1               ;
0000EFr 1               ; func_data = (call_gfx_set_palette_from_assset_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
0000EFr 1               ;
0000EFr 1  20 rr rr     	jsr     decsp3
0000F2r 1  A2 F1        	ldx     #$F1
0000F4r 1  A9 00        	lda     #$00
0000F6r 1  20 rr rr     	jsr     stax0sp
0000F9r 1               ;
0000F9r 1               ; func_data->hdr.func_type = 1;
0000F9r 1               ;
0000F9r 1  85 rr        	sta     ptr1
0000FBr 1  86 rr        	stx     ptr1+1
0000FDr 1  A9 01        	lda     #$01
0000FFr 1  A0 00        	ldy     #$00
000101r 1  91 rr        	sta     (ptr1),y
000103r 1               ;
000103r 1               ; func_data->hdr.func_id = 4;
000103r 1               ;
000103r 1  C8           	iny
000104r 1  B1 rr        	lda     (sp),y
000106r 1  85 rr        	sta     ptr1+1
000108r 1  88           	dey
000109r 1  B1 rr        	lda     (sp),y
00010Br 1  85 rr        	sta     ptr1
00010Dr 1  A9 04        	lda     #$04
00010Fr 1  C8           	iny
000110r 1  91 rr        	sta     (ptr1),y
000112r 1               ;
000112r 1               ; func_data->asset_id=asset_id;
000112r 1               ;
000112r 1  B1 rr        	lda     (sp),y
000114r 1  85 rr        	sta     ptr1+1
000116r 1  88           	dey
000117r 1  B1 rr        	lda     (sp),y
000119r 1  85 rr        	sta     ptr1
00011Br 1  A0 04        	ldy     #$04
00011Dr 1  B1 rr        	lda     (sp),y
00011Fr 1  A0 02        	ldy     #$02
000121r 1  91 rr        	sta     (ptr1),y
000123r 1               ;
000123r 1               ; func_data->fill_unused_with_idx=fill_unused_with_idx;
000123r 1               ;
000123r 1  88           	dey
000124r 1  B1 rr        	lda     (sp),y
000126r 1  85 rr        	sta     ptr1+1
000128r 1  88           	dey
000129r 1  B1 rr        	lda     (sp),y
00012Br 1  85 rr        	sta     ptr1
00012Dr 1  A0 03        	ldy     #$03
00012Fr 1  B1 rr        	lda     (sp),y
000131r 1  91 rr        	sta     (ptr1),y
000133r 1               ;
000133r 1               ; result_code = *call_function;
000133r 1               ;
000133r 1  AD rr rr     	lda     _call_function+1
000136r 1  85 rr        	sta     ptr1+1
000138r 1  AD rr rr     	lda     _call_function
00013Br 1  85 rr        	sta     ptr1
00013Dr 1  A0 00        	ldy     #$00
00013Fr 1  B1 rr        	lda     (ptr1),y
000141r 1  A0 02        	ldy     #$02
000143r 1  91 rr        	sta     (sp),y
000145r 1               ;
000145r 1               ; }
000145r 1               ;
000145r 1  4C rr rr     	jmp     incsp5
000148r 1               
000148r 1               .endproc
000148r 1               
000148r 1               ; ---------------------------------------------------------------
000148r 1               ; void __near__ gfx_set_font_from_asset (unsigned char)
000148r 1               ; ---------------------------------------------------------------
000148r 1               
000148r 1               .segment	"CODE"
000148r 1               
000148r 1               .proc	_gfx_set_font_from_asset: near
000148r 1               
000148r 1               .segment	"CODE"
000148r 1               
000148r 1               ;
000148r 1               ; void     gfx_set_font_from_asset(uint8_t asset_id){
000148r 1               ;
000148r 1  20 rr rr     	jsr     pusha
00014Br 1               ;
00014Br 1               ; func_data = (call_gfx_set_font_from_asset_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00014Br 1               ;
00014Br 1  20 rr rr     	jsr     decsp3
00014Er 1  A2 F1        	ldx     #$F1
000150r 1  A9 00        	lda     #$00
000152r 1  20 rr rr     	jsr     stax0sp
000155r 1               ;
000155r 1               ; func_data->hdr.func_type = 1;
000155r 1               ;
000155r 1  85 rr        	sta     ptr1
000157r 1  86 rr        	stx     ptr1+1
000159r 1  A9 01        	lda     #$01
00015Br 1  A0 00        	ldy     #$00
00015Dr 1  91 rr        	sta     (ptr1),y
00015Fr 1               ;
00015Fr 1               ; func_data->hdr.func_id = 5;
00015Fr 1               ;
00015Fr 1  C8           	iny
000160r 1  B1 rr        	lda     (sp),y
000162r 1  85 rr        	sta     ptr1+1
000164r 1  88           	dey
000165r 1  B1 rr        	lda     (sp),y
000167r 1  85 rr        	sta     ptr1
000169r 1  A9 05        	lda     #$05
00016Br 1  C8           	iny
00016Cr 1  91 rr        	sta     (ptr1),y
00016Er 1               ;
00016Er 1               ; func_data->asset_id=asset_id;
00016Er 1               ;
00016Er 1  B1 rr        	lda     (sp),y
000170r 1  85 rr        	sta     ptr1+1
000172r 1  88           	dey
000173r 1  B1 rr        	lda     (sp),y
000175r 1  85 rr        	sta     ptr1
000177r 1  A0 03        	ldy     #$03
000179r 1  B1 rr        	lda     (sp),y
00017Br 1  88           	dey
00017Cr 1  91 rr        	sta     (ptr1),y
00017Er 1               ;
00017Er 1               ; result_code = *call_function;
00017Er 1               ;
00017Er 1  AD rr rr     	lda     _call_function+1
000181r 1  85 rr        	sta     ptr1+1
000183r 1  AD rr rr     	lda     _call_function
000186r 1  85 rr        	sta     ptr1
000188r 1  A0 00        	ldy     #$00
00018Ar 1  B1 rr        	lda     (ptr1),y
00018Cr 1  A0 02        	ldy     #$02
00018Er 1  91 rr        	sta     (sp),y
000190r 1               ;
000190r 1               ; }
000190r 1               ;
000190r 1  4C rr rr     	jmp     incsp4
000193r 1               
000193r 1               .endproc
000193r 1               
000193r 1               ; ---------------------------------------------------------------
000193r 1               ; unsigned char __near__ gfx_get_pixel (unsigned int, unsigned int)
000193r 1               ; ---------------------------------------------------------------
000193r 1               
000193r 1               .segment	"CODE"
000193r 1               
000193r 1               .proc	_gfx_get_pixel: near
000193r 1               
000193r 1               .segment	"CODE"
000193r 1               
000193r 1               ;
000193r 1               ; uint8_t  gfx_get_pixel(uint16_t x, uint16_t y){
000193r 1               ;
000193r 1  20 rr rr     	jsr     pushax
000196r 1               ;
000196r 1               ; func_data = (call_gfx_get_pixel_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000196r 1               ;
000196r 1  20 rr rr     	jsr     decsp3
000199r 1  A2 F1        	ldx     #$F1
00019Br 1  A9 00        	lda     #$00
00019Dr 1  20 rr rr     	jsr     stax0sp
0001A0r 1               ;
0001A0r 1               ; func_data->hdr.func_type = 1;
0001A0r 1               ;
0001A0r 1  85 rr        	sta     ptr1
0001A2r 1  86 rr        	stx     ptr1+1
0001A4r 1  A9 01        	lda     #$01
0001A6r 1  A0 00        	ldy     #$00
0001A8r 1  91 rr        	sta     (ptr1),y
0001AAr 1               ;
0001AAr 1               ; func_data->hdr.func_id = 6;
0001AAr 1               ;
0001AAr 1  C8           	iny
0001ABr 1  B1 rr        	lda     (sp),y
0001ADr 1  85 rr        	sta     ptr1+1
0001AFr 1  88           	dey
0001B0r 1  B1 rr        	lda     (sp),y
0001B2r 1  85 rr        	sta     ptr1
0001B4r 1  A9 06        	lda     #$06
0001B6r 1  C8           	iny
0001B7r 1  91 rr        	sta     (ptr1),y
0001B9r 1               ;
0001B9r 1               ; func_data->x=x;
0001B9r 1               ;
0001B9r 1  B1 rr        	lda     (sp),y
0001BBr 1  85 rr        	sta     ptr1+1
0001BDr 1  88           	dey
0001BEr 1  B1 rr        	lda     (sp),y
0001C0r 1  85 rr        	sta     ptr1
0001C2r 1  A0 06        	ldy     #$06
0001C4r 1  B1 rr        	lda     (sp),y
0001C6r 1  AA           	tax
0001C7r 1  88           	dey
0001C8r 1  B1 rr        	lda     (sp),y
0001CAr 1  A0 02        	ldy     #$02
0001CCr 1  91 rr        	sta     (ptr1),y
0001CEr 1  C8           	iny
0001CFr 1  8A           	txa
0001D0r 1  91 rr        	sta     (ptr1),y
0001D2r 1               ;
0001D2r 1               ; func_data->y=y;
0001D2r 1               ;
0001D2r 1  A0 01        	ldy     #$01
0001D4r 1  B1 rr        	lda     (sp),y
0001D6r 1  85 rr        	sta     ptr1+1
0001D8r 1  88           	dey
0001D9r 1  B1 rr        	lda     (sp),y
0001DBr 1  85 rr        	sta     ptr1
0001DDr 1  A0 04        	ldy     #$04
0001DFr 1  B1 rr        	lda     (sp),y
0001E1r 1  AA           	tax
0001E2r 1  88           	dey
0001E3r 1  B1 rr        	lda     (sp),y
0001E5r 1  C8           	iny
0001E6r 1  91 rr        	sta     (ptr1),y
0001E8r 1  C8           	iny
0001E9r 1  8A           	txa
0001EAr 1  91 rr        	sta     (ptr1),y
0001ECr 1               ;
0001ECr 1               ; result_code = *call_function;
0001ECr 1               ;
0001ECr 1  AD rr rr     	lda     _call_function+1
0001EFr 1  85 rr        	sta     ptr1+1
0001F1r 1  AD rr rr     	lda     _call_function
0001F4r 1  85 rr        	sta     ptr1
0001F6r 1  A0 00        	ldy     #$00
0001F8r 1  B1 rr        	lda     (ptr1),y
0001FAr 1  A0 02        	ldy     #$02
0001FCr 1  91 rr        	sta     (sp),y
0001FEr 1               ;
0001FEr 1               ; return *((uint8_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN));
0001FEr 1               ;
0001FEr 1  A2 00        	ldx     #$00
000200r 1  AD 00 F1     	lda     $F100
000203r 1               ;
000203r 1               ; }
000203r 1               ;
000203r 1  4C rr rr     	jmp     incsp7
000206r 1               
000206r 1               .endproc
000206r 1               
000206r 1               ; ---------------------------------------------------------------
000206r 1               ; void __near__ gfx_draw_pixel (unsigned int, unsigned int, unsigned char)
000206r 1               ; ---------------------------------------------------------------
000206r 1               
000206r 1               .segment	"CODE"
000206r 1               
000206r 1               .proc	_gfx_draw_pixel: near
000206r 1               
000206r 1               .segment	"CODE"
000206r 1               
000206r 1               ;
000206r 1               ; void     gfx_draw_pixel(uint16_t x, uint16_t y, uint8_t color_idx){
000206r 1               ;
000206r 1  20 rr rr     	jsr     pusha
000209r 1               ;
000209r 1               ; func_data = (call_gfx_draw_pixel_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000209r 1               ;
000209r 1  20 rr rr     	jsr     decsp3
00020Cr 1  A2 F1        	ldx     #$F1
00020Er 1  A9 00        	lda     #$00
000210r 1  20 rr rr     	jsr     stax0sp
000213r 1               ;
000213r 1               ; func_data->hdr.func_type = 1;
000213r 1               ;
000213r 1  85 rr        	sta     ptr1
000215r 1  86 rr        	stx     ptr1+1
000217r 1  A9 01        	lda     #$01
000219r 1  A0 00        	ldy     #$00
00021Br 1  91 rr        	sta     (ptr1),y
00021Dr 1               ;
00021Dr 1               ; func_data->hdr.func_id = 7;
00021Dr 1               ;
00021Dr 1  C8           	iny
00021Er 1  B1 rr        	lda     (sp),y
000220r 1  85 rr        	sta     ptr1+1
000222r 1  88           	dey
000223r 1  B1 rr        	lda     (sp),y
000225r 1  85 rr        	sta     ptr1
000227r 1  A9 07        	lda     #$07
000229r 1  C8           	iny
00022Ar 1  91 rr        	sta     (ptr1),y
00022Cr 1               ;
00022Cr 1               ; func_data->x=x;
00022Cr 1               ;
00022Cr 1  B1 rr        	lda     (sp),y
00022Er 1  85 rr        	sta     ptr1+1
000230r 1  88           	dey
000231r 1  B1 rr        	lda     (sp),y
000233r 1  85 rr        	sta     ptr1
000235r 1  A0 07        	ldy     #$07
000237r 1  B1 rr        	lda     (sp),y
000239r 1  AA           	tax
00023Ar 1  88           	dey
00023Br 1  B1 rr        	lda     (sp),y
00023Dr 1  A0 02        	ldy     #$02
00023Fr 1  91 rr        	sta     (ptr1),y
000241r 1  C8           	iny
000242r 1  8A           	txa
000243r 1  91 rr        	sta     (ptr1),y
000245r 1               ;
000245r 1               ; func_data->y=y;
000245r 1               ;
000245r 1  A0 01        	ldy     #$01
000247r 1  B1 rr        	lda     (sp),y
000249r 1  85 rr        	sta     ptr1+1
00024Br 1  88           	dey
00024Cr 1  B1 rr        	lda     (sp),y
00024Er 1  85 rr        	sta     ptr1
000250r 1  A0 05        	ldy     #$05
000252r 1  B1 rr        	lda     (sp),y
000254r 1  AA           	tax
000255r 1  88           	dey
000256r 1  B1 rr        	lda     (sp),y
000258r 1  91 rr        	sta     (ptr1),y
00025Ar 1  C8           	iny
00025Br 1  8A           	txa
00025Cr 1  91 rr        	sta     (ptr1),y
00025Er 1               ;
00025Er 1               ; func_data->color_idx=color_idx;
00025Er 1               ;
00025Er 1  A0 01        	ldy     #$01
000260r 1  B1 rr        	lda     (sp),y
000262r 1  85 rr        	sta     ptr1+1
000264r 1  88           	dey
000265r 1  B1 rr        	lda     (sp),y
000267r 1  85 rr        	sta     ptr1
000269r 1  A0 03        	ldy     #$03
00026Br 1  B1 rr        	lda     (sp),y
00026Dr 1  A0 06        	ldy     #$06
00026Fr 1  91 rr        	sta     (ptr1),y
000271r 1               ;
000271r 1               ; result_code = *call_function;
000271r 1               ;
000271r 1  AD rr rr     	lda     _call_function+1
000274r 1  85 rr        	sta     ptr1+1
000276r 1  AD rr rr     	lda     _call_function
000279r 1  85 rr        	sta     ptr1
00027Br 1  A0 00        	ldy     #$00
00027Dr 1  B1 rr        	lda     (ptr1),y
00027Fr 1  A0 02        	ldy     #$02
000281r 1  91 rr        	sta     (sp),y
000283r 1               ;
000283r 1               ; }
000283r 1               ;
000283r 1  4C rr rr     	jmp     incsp8
000286r 1               
000286r 1               .endproc
000286r 1               
000286r 1               ; ---------------------------------------------------------------
000286r 1               ; void __near__ gfx_draw_char (unsigned int, unsigned int, unsigned char, unsigned char)
000286r 1               ; ---------------------------------------------------------------
000286r 1               
000286r 1               .segment	"CODE"
000286r 1               
000286r 1               .proc	_gfx_draw_char: near
000286r 1               
000286r 1               .segment	"CODE"
000286r 1               
000286r 1               ;
000286r 1               ; void     gfx_draw_char(uint16_t x, uint16_t y, char ch, uint8_t color_idx){
000286r 1               ;
000286r 1  20 rr rr     	jsr     pusha
000289r 1               ;
000289r 1               ; func_data = (call_gfx_draw_char_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
000289r 1               ;
000289r 1  20 rr rr     	jsr     decsp3
00028Cr 1  A2 F1        	ldx     #$F1
00028Er 1  A9 00        	lda     #$00
000290r 1  20 rr rr     	jsr     stax0sp
000293r 1               ;
000293r 1               ; func_data->hdr.func_type = 1;
000293r 1               ;
000293r 1  85 rr        	sta     ptr1
000295r 1  86 rr        	stx     ptr1+1
000297r 1  A9 01        	lda     #$01
000299r 1  A0 00        	ldy     #$00
00029Br 1  91 rr        	sta     (ptr1),y
00029Dr 1               ;
00029Dr 1               ; func_data->hdr.func_id = 8;
00029Dr 1               ;
00029Dr 1  C8           	iny
00029Er 1  B1 rr        	lda     (sp),y
0002A0r 1  85 rr        	sta     ptr1+1
0002A2r 1  88           	dey
0002A3r 1  B1 rr        	lda     (sp),y
0002A5r 1  85 rr        	sta     ptr1
0002A7r 1  A9 08        	lda     #$08
0002A9r 1  C8           	iny
0002AAr 1  91 rr        	sta     (ptr1),y
0002ACr 1               ;
0002ACr 1               ; func_data->x=x;
0002ACr 1               ;
0002ACr 1  B1 rr        	lda     (sp),y
0002AEr 1  85 rr        	sta     ptr1+1
0002B0r 1  88           	dey
0002B1r 1  B1 rr        	lda     (sp),y
0002B3r 1  85 rr        	sta     ptr1
0002B5r 1  A0 08        	ldy     #$08
0002B7r 1  B1 rr        	lda     (sp),y
0002B9r 1  AA           	tax
0002BAr 1  88           	dey
0002BBr 1  B1 rr        	lda     (sp),y
0002BDr 1  A0 02        	ldy     #$02
0002BFr 1  91 rr        	sta     (ptr1),y
0002C1r 1  C8           	iny
0002C2r 1  8A           	txa
0002C3r 1  91 rr        	sta     (ptr1),y
0002C5r 1               ;
0002C5r 1               ; func_data->y=y;
0002C5r 1               ;
0002C5r 1  A0 01        	ldy     #$01
0002C7r 1  B1 rr        	lda     (sp),y
0002C9r 1  85 rr        	sta     ptr1+1
0002CBr 1  88           	dey
0002CCr 1  B1 rr        	lda     (sp),y
0002CEr 1  85 rr        	sta     ptr1
0002D0r 1  A0 06        	ldy     #$06
0002D2r 1  B1 rr        	lda     (sp),y
0002D4r 1  AA           	tax
0002D5r 1  88           	dey
0002D6r 1  B1 rr        	lda     (sp),y
0002D8r 1  88           	dey
0002D9r 1  91 rr        	sta     (ptr1),y
0002DBr 1  C8           	iny
0002DCr 1  8A           	txa
0002DDr 1  91 rr        	sta     (ptr1),y
0002DFr 1               ;
0002DFr 1               ; func_data->ch=ch;
0002DFr 1               ;
0002DFr 1  A0 01        	ldy     #$01
0002E1r 1  B1 rr        	lda     (sp),y
0002E3r 1  85 rr        	sta     ptr1+1
0002E5r 1  88           	dey
0002E6r 1  B1 rr        	lda     (sp),y
0002E8r 1  85 rr        	sta     ptr1
0002EAr 1  A0 04        	ldy     #$04
0002ECr 1  B1 rr        	lda     (sp),y
0002EEr 1  A0 06        	ldy     #$06
0002F0r 1  91 rr        	sta     (ptr1),y
0002F2r 1               ;
0002F2r 1               ; func_data->color_idx=color_idx;
0002F2r 1               ;
0002F2r 1  A0 01        	ldy     #$01
0002F4r 1  B1 rr        	lda     (sp),y
0002F6r 1  85 rr        	sta     ptr1+1
0002F8r 1  88           	dey
0002F9r 1  B1 rr        	lda     (sp),y
0002FBr 1  85 rr        	sta     ptr1
0002FDr 1  A0 03        	ldy     #$03
0002FFr 1  B1 rr        	lda     (sp),y
000301r 1  A0 07        	ldy     #$07
000303r 1  91 rr        	sta     (ptr1),y
000305r 1               ;
000305r 1               ; result_code = *call_function;
000305r 1               ;
000305r 1  AD rr rr     	lda     _call_function+1
000308r 1  85 rr        	sta     ptr1+1
00030Ar 1  AD rr rr     	lda     _call_function
00030Dr 1  85 rr        	sta     ptr1
00030Fr 1  A0 00        	ldy     #$00
000311r 1  B1 rr        	lda     (ptr1),y
000313r 1  A0 02        	ldy     #$02
000315r 1  91 rr        	sta     (sp),y
000317r 1               ;
000317r 1               ; }
000317r 1               ;
000317r 1  A0 09        	ldy     #$09
000319r 1  4C rr rr     	jmp     addysp
00031Cr 1               
00031Cr 1               .endproc
00031Cr 1               
00031Cr 1               ; ---------------------------------------------------------------
00031Cr 1               ; unsigned char __near__ io_keyboard_is_pressed (unsigned char)
00031Cr 1               ; ---------------------------------------------------------------
00031Cr 1               
00031Cr 1               .segment	"CODE"
00031Cr 1               
00031Cr 1               .proc	_io_keyboard_is_pressed: near
00031Cr 1               
00031Cr 1               .segment	"CODE"
00031Cr 1               
00031Cr 1               ;
00031Cr 1               ; bool io_keyboard_is_pressed(uint8_t keycode){
00031Cr 1               ;
00031Cr 1  20 rr rr     	jsr     pusha
00031Fr 1               ;
00031Fr 1               ; func_data = (call_io_keyboard_is_pressed_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00031Fr 1               ;
00031Fr 1  20 rr rr     	jsr     decsp3
000322r 1  A2 F1        	ldx     #$F1
000324r 1  A9 00        	lda     #$00
000326r 1  20 rr rr     	jsr     stax0sp
000329r 1               ;
000329r 1               ; func_data->hdr.func_type = 2;
000329r 1               ;
000329r 1  85 rr        	sta     ptr1
00032Br 1  86 rr        	stx     ptr1+1
00032Dr 1  A9 02        	lda     #$02
00032Fr 1  A0 00        	ldy     #$00
000331r 1  91 rr        	sta     (ptr1),y
000333r 1               ;
000333r 1               ; func_data->hdr.func_id = 1;
000333r 1               ;
000333r 1  C8           	iny
000334r 1  B1 rr        	lda     (sp),y
000336r 1  85 rr        	sta     ptr1+1
000338r 1  88           	dey
000339r 1  B1 rr        	lda     (sp),y
00033Br 1  85 rr        	sta     ptr1
00033Dr 1  A9 01        	lda     #$01
00033Fr 1  C8           	iny
000340r 1  91 rr        	sta     (ptr1),y
000342r 1               ;
000342r 1               ; func_data->keycode=keycode;
000342r 1               ;
000342r 1  B1 rr        	lda     (sp),y
000344r 1  85 rr        	sta     ptr1+1
000346r 1  88           	dey
000347r 1  B1 rr        	lda     (sp),y
000349r 1  85 rr        	sta     ptr1
00034Br 1  A0 03        	ldy     #$03
00034Dr 1  B1 rr        	lda     (sp),y
00034Fr 1  88           	dey
000350r 1  91 rr        	sta     (ptr1),y
000352r 1               ;
000352r 1               ; result_code = *call_function;
000352r 1               ;
000352r 1  AD rr rr     	lda     _call_function+1
000355r 1  85 rr        	sta     ptr1+1
000357r 1  AD rr rr     	lda     _call_function
00035Ar 1  85 rr        	sta     ptr1
00035Cr 1  A0 00        	ldy     #$00
00035Er 1  B1 rr        	lda     (ptr1),y
000360r 1  A0 02        	ldy     #$02
000362r 1  91 rr        	sta     (sp),y
000364r 1               ;
000364r 1               ; return *((bool*)(MEMORY_MAP_CALL_BUFFER_BEGIN));
000364r 1               ;
000364r 1  A2 00        	ldx     #$00
000366r 1  AD 00 F1     	lda     $F100
000369r 1               ;
000369r 1               ; }
000369r 1               ;
000369r 1  4C rr rr     	jmp     incsp4
00036Cr 1               
00036Cr 1               .endproc
00036Cr 1               
00036Cr 1               ; ---------------------------------------------------------------
00036Cr 1               ; unsigned char __near__ io_keyboard_is_down (unsigned char)
00036Cr 1               ; ---------------------------------------------------------------
00036Cr 1               
00036Cr 1               .segment	"CODE"
00036Cr 1               
00036Cr 1               .proc	_io_keyboard_is_down: near
00036Cr 1               
00036Cr 1               .segment	"CODE"
00036Cr 1               
00036Cr 1               ;
00036Cr 1               ; bool io_keyboard_is_down(uint8_t keycode){
00036Cr 1               ;
00036Cr 1  20 rr rr     	jsr     pusha
00036Fr 1               ;
00036Fr 1               ; func_data = (call_io_keyboard_is_down_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
00036Fr 1               ;
00036Fr 1  20 rr rr     	jsr     decsp3
000372r 1  A2 F1        	ldx     #$F1
000374r 1  A9 00        	lda     #$00
000376r 1  20 rr rr     	jsr     stax0sp
000379r 1               ;
000379r 1               ; func_data->hdr.func_type = 2;
000379r 1               ;
000379r 1  85 rr        	sta     ptr1
00037Br 1  86 rr        	stx     ptr1+1
00037Dr 1  A9 02        	lda     #$02
00037Fr 1  A0 00        	ldy     #$00
000381r 1  91 rr        	sta     (ptr1),y
000383r 1               ;
000383r 1               ; func_data->hdr.func_id = 2;
000383r 1               ;
000383r 1  C8           	iny
000384r 1  B1 rr        	lda     (sp),y
000386r 1  85 rr        	sta     ptr1+1
000388r 1  88           	dey
000389r 1  B1 rr        	lda     (sp),y
00038Br 1  85 rr        	sta     ptr1
00038Dr 1  A9 02        	lda     #$02
00038Fr 1  C8           	iny
000390r 1  91 rr        	sta     (ptr1),y
000392r 1               ;
000392r 1               ; func_data->keycode=keycode;
000392r 1               ;
000392r 1  B1 rr        	lda     (sp),y
000394r 1  85 rr        	sta     ptr1+1
000396r 1  88           	dey
000397r 1  B1 rr        	lda     (sp),y
000399r 1  85 rr        	sta     ptr1
00039Br 1  A0 03        	ldy     #$03
00039Dr 1  B1 rr        	lda     (sp),y
00039Fr 1  88           	dey
0003A0r 1  91 rr        	sta     (ptr1),y
0003A2r 1               ;
0003A2r 1               ; result_code = *call_function;
0003A2r 1               ;
0003A2r 1  AD rr rr     	lda     _call_function+1
0003A5r 1  85 rr        	sta     ptr1+1
0003A7r 1  AD rr rr     	lda     _call_function
0003AAr 1  85 rr        	sta     ptr1
0003ACr 1  A0 00        	ldy     #$00
0003AEr 1  B1 rr        	lda     (ptr1),y
0003B0r 1  A0 02        	ldy     #$02
0003B2r 1  91 rr        	sta     (sp),y
0003B4r 1               ;
0003B4r 1               ; return *((bool*)(MEMORY_MAP_CALL_BUFFER_BEGIN));
0003B4r 1               ;
0003B4r 1  A2 00        	ldx     #$00
0003B6r 1  AD 00 F1     	lda     $F100
0003B9r 1               ;
0003B9r 1               ; }
0003B9r 1               ;
0003B9r 1  4C rr rr     	jmp     incsp4
0003BCr 1               
0003BCr 1               .endproc
0003BCr 1               
0003BCr 1               ; ---------------------------------------------------------------
0003BCr 1               ; unsigned char __near__ io_keyboard_is_released (unsigned char)
0003BCr 1               ; ---------------------------------------------------------------
0003BCr 1               
0003BCr 1               .segment	"CODE"
0003BCr 1               
0003BCr 1               .proc	_io_keyboard_is_released: near
0003BCr 1               
0003BCr 1               .segment	"CODE"
0003BCr 1               
0003BCr 1               ;
0003BCr 1               ; bool io_keyboard_is_released(uint8_t keycode){
0003BCr 1               ;
0003BCr 1  20 rr rr     	jsr     pusha
0003BFr 1               ;
0003BFr 1               ; func_data = (call_io_keyboard_is_released_t*)(MEMORY_MAP_CALL_BUFFER_BEGIN);
0003BFr 1               ;
0003BFr 1  20 rr rr     	jsr     decsp3
0003C2r 1  A2 F1        	ldx     #$F1
0003C4r 1  A9 00        	lda     #$00
0003C6r 1  20 rr rr     	jsr     stax0sp
0003C9r 1               ;
0003C9r 1               ; func_data->hdr.func_type = 2;
0003C9r 1               ;
0003C9r 1  85 rr        	sta     ptr1
0003CBr 1  86 rr        	stx     ptr1+1
0003CDr 1  A9 02        	lda     #$02
0003CFr 1  A0 00        	ldy     #$00
0003D1r 1  91 rr        	sta     (ptr1),y
0003D3r 1               ;
0003D3r 1               ; func_data->hdr.func_id = 3;
0003D3r 1               ;
0003D3r 1  C8           	iny
0003D4r 1  B1 rr        	lda     (sp),y
0003D6r 1  85 rr        	sta     ptr1+1
0003D8r 1  88           	dey
0003D9r 1  B1 rr        	lda     (sp),y
0003DBr 1  85 rr        	sta     ptr1
0003DDr 1  A9 03        	lda     #$03
0003DFr 1  C8           	iny
0003E0r 1  91 rr        	sta     (ptr1),y
0003E2r 1               ;
0003E2r 1               ; func_data->keycode=keycode;
0003E2r 1               ;
0003E2r 1  B1 rr        	lda     (sp),y
0003E4r 1  85 rr        	sta     ptr1+1
0003E6r 1  88           	dey
0003E7r 1  B1 rr        	lda     (sp),y
0003E9r 1  85 rr        	sta     ptr1
0003EBr 1  A0 03        	ldy     #$03
0003EDr 1  B1 rr        	lda     (sp),y
0003EFr 1  88           	dey
0003F0r 1  91 rr        	sta     (ptr1),y
0003F2r 1               ;
0003F2r 1               ; result_code = *call_function;
0003F2r 1               ;
0003F2r 1  AD rr rr     	lda     _call_function+1
0003F5r 1  85 rr        	sta     ptr1+1
0003F7r 1  AD rr rr     	lda     _call_function
0003FAr 1  85 rr        	sta     ptr1
0003FCr 1  A0 00        	ldy     #$00
0003FEr 1  B1 rr        	lda     (ptr1),y
000400r 1  A0 02        	ldy     #$02
000402r 1  91 rr        	sta     (sp),y
000404r 1               ;
000404r 1               ; return *((bool*)(MEMORY_MAP_CALL_BUFFER_BEGIN));
000404r 1               ;
000404r 1  A2 00        	ldx     #$00
000406r 1  AD 00 F1     	lda     $F100
000409r 1               ;
000409r 1               ; }
000409r 1               ;
000409r 1  4C rr rr     	jmp     incsp4
00040Cr 1               
00040Cr 1               .endproc
00040Cr 1               
00040Cr 1               ; ---------------------------------------------------------------
00040Cr 1               ; int __near__ main (void)
00040Cr 1               ; ---------------------------------------------------------------
00040Cr 1               
00040Cr 1               .segment	"CODE"
00040Cr 1               
00040Cr 1               .proc	_main: near
00040Cr 1               
00040Cr 1               .segment	"CODE"
00040Cr 1               
00040Cr 1               ;
00040Cr 1               ; uint8_t* tile_map = (uint8_t*)MEMORY_TILEAREA_BEGIN;
00040Cr 1               ;
00040Cr 1  20 rr rr     	jsr     decsp3
00040Fr 1  A2 F1        	ldx     #$F1
000411r 1  A9 0B        	lda     #$0B
000413r 1  20 rr rr     	jsr     pushax
000416r 1               ;
000416r 1               ; palette = ASSET_COLOR_PALETTE;
000416r 1               ;
000416r 1  20 rr rr     	jsr     decsp1
000419r 1  A9 00        	lda     #$00
00041Br 1  A8           	tay
00041Cr 1  91 rr        	sta     (sp),y
00041Er 1               ;
00041Er 1               ; timer = 0;
00041Er 1               ;
00041Er 1  A0 05        	ldy     #$05
000420r 1  91 rr        	sta     (sp),y
000422r 1               ;
000422r 1               ; rows = 0;
000422r 1               ;
000422r 1  A0 03        	ldy     #$03
000424r 1  91 rr        	sta     (sp),y
000426r 1               ;
000426r 1               ; pos_x = 0;
000426r 1               ;
000426r 1  C8           	iny
000427r 1  91 rr        	sta     (sp),y
000429r 1               ;
000429r 1               ; gfx_set_palette_from_assset(ASSET_COLOR_PALETTE_SMALL,0);
000429r 1               ;
000429r 1  A9 01        	lda     #$01
00042Br 1  20 rr rr     L00D6:	jsr     pusha
00042Er 1  A9 00        	lda     #$00
000430r 1  20 rr rr     	jsr     _gfx_set_palette_from_assset
000433r 1               ;
000433r 1               ; pos_x++;
000433r 1               ;
000433r 1  A0 04        	ldy     #$04
000435r 1  B1 rr        L00D1:	lda     (sp),y
000437r 1  18           	clc
000438r 1  69 01        	adc     #$01
00043Ar 1  91 rr        	sta     (sp),y
00043Cr 1               ;
00043Cr 1               ; *(tile_map+10*40+pos_x)=pos_x+rows;
00043Cr 1               ;
00043Cr 1  A0 02        	ldy     #$02
00043Er 1  B1 rr        	lda     (sp),y
000440r 1  AA           	tax
000441r 1  88           	dey
000442r 1  B1 rr        	lda     (sp),y
000444r 1  18           	clc
000445r 1  69 90        	adc     #$90
000447r 1  90 01        	bcc     L00B9
000449r 1  E8           	inx
00044Ar 1  E8           L00B9:	inx
00044Br 1  85 rr        	sta     ptr1
00044Dr 1  86 rr        	stx     ptr1+1
00044Fr 1  A0 04        	ldy     #$04
000451r 1  B1 rr        	lda     (sp),y
000453r 1  18           	clc
000454r 1  65 rr        	adc     ptr1
000456r 1  A6 rr        	ldx     ptr1+1
000458r 1  90 01        	bcc     L00CD
00045Ar 1  E8           	inx
00045Br 1  85 rr        L00CD:	sta     ptr1
00045Dr 1  86 rr        	stx     ptr1+1
00045Fr 1  88           	dey
000460r 1  B1 rr        	lda     (sp),y
000462r 1  18           	clc
000463r 1  C8           	iny
000464r 1  71 rr        	adc     (sp),y
000466r 1  A0 00        	ldy     #$00
000468r 1  91 rr        	sta     (ptr1),y
00046Ar 1               ;
00046Ar 1               ; if (rows>=100){
00046Ar 1               ;
00046Ar 1  A0 03        	ldy     #$03
00046Cr 1  B1 rr        	lda     (sp),y
00046Er 1  C9 64        	cmp     #$64
000470r 1  90 04        	bcc     L00BB
000472r 1               ;
000472r 1               ; rows=0;
000472r 1               ;
000472r 1  A9 00        	lda     #$00
000474r 1  91 rr        	sta     (sp),y
000476r 1               ;
000476r 1               ; if (pos_x==0){
000476r 1               ;
000476r 1  C8           L00BB:	iny
000477r 1  B1 rr        	lda     (sp),y
000479r 1  D0 BA        	bne     L00D1
00047Br 1               ;
00047Br 1               ; rows++;
00047Br 1               ;
00047Br 1  88           	dey
00047Cr 1  B1 rr        	lda     (sp),y
00047Er 1  18           	clc
00047Fr 1  69 01        	adc     #$01
000481r 1  91 rr        	sta     (sp),y
000483r 1               ;
000483r 1               ; palette = (palette == ASSET_COLOR_PALETTE_SMALL) ? ASSET_COLOR_PALETTE : ASSET_COLOR_PALETTE_SMALL;
000483r 1               ;
000483r 1  A0 00        	ldy     #$00
000485r 1  B1 rr        	lda     (sp),y
000487r 1  C9 01        	cmp     #$01
000489r 1  D0 04        	bne     L00D2
00048Br 1  98           	tya
00048Cr 1  4C rr rr     	jmp     L00D4
00048Fr 1  A9 01        L00D2:	lda     #$01
000491r 1  91 rr        L00D4:	sta     (sp),y
000493r 1               ;
000493r 1               ; while (1){
000493r 1               ;
000493r 1  4C rr rr     	jmp     L00D6
000496r 1               
000496r 1               .endproc
000496r 1               
000496r 1               
